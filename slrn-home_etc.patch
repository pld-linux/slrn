diff -Nru slrn-0.9.6.3/slrn.lis slrn-0.9.6.3.new/slrn.lis
--- slrn-0.9.6.3/slrn.lis	Mon Sep 18 09:03:13 2000
+++ slrn-0.9.6.3.new/slrn.lis	Mon Sep 18 09:04:42 2000
@@ -138,3 +138,5 @@
 @src/slrndir.h
 @src/vfile.h
 @src/vfile.c
+@src/userdir.c
+@src/userdir.h
diff -Nru slrn-0.9.6.3/src/modules.lis slrn-0.9.6.3.new/src/modules.lis
--- slrn-0.9.6.3/src/modules.lis	Mon Sep 18 09:03:13 2000
+++ slrn-0.9.6.3.new/src/modules.lis	Mon Sep 18 09:02:06 2000
@@ -13,6 +13,7 @@
 score
 server
 sortdate
+userdir
 slrn
 startup
 ttymsg
diff -Nru slrn-0.9.6.3/src/slrn.c slrn-0.9.6.3.new/src/slrn.c
--- slrn-0.9.6.3/src/slrn.c	Mon Sep 18 09:03:13 2000
+++ slrn-0.9.6.3.new/src/slrn.c	Mon Sep 18 09:02:06 2000
@@ -67,6 +67,8 @@
 #include <slang.h>
 #include "jdmacros.h"
 
+#include "userdir.h"
+#include <sys/param.h>
 
 #include <errno.h>
 
@@ -972,7 +974,22 @@
    int use_active = 0;
    FILE *fp;
    char file [SLRN_MAX_PATH_LEN];
-   char *init_file = SLRN_USER_SLRNRC_FILENAME;
+   char *init_file;
+
+   struct cfv etcfile;
+   struct cfv newsfile;
+   etcfile.variable = "CONFIG_DIR";
+   etcfile.home_dir = NULL;
+   etcfile.home_scd = NULL;
+   etcfile.subname = "slrnrc";
+   etcfile.prefix = ".";
+   etcfile.suffix = "";
+   etcfile.mode = M_REGULAR_FILE;
+
+   if ((notnullusercfv (&etcfile)) != -1)
+       init_file = etcfile.result;
+   else
+       init_file = SLRN_USER_SLRNRC_FILENAME;
 
 #ifdef HAVE_SETLOCALE
 # ifdef LC_CTYPE
@@ -1195,7 +1212,18 @@
 #if defined(VMS) || defined(IBMPC_SYSTEM)
      Slrn_Newsrc_File = "jnews.rc";
 #else
-   Slrn_Newsrc_File = ".jnewsrc";
+   newsfile.variable = "CONFIG_DIR";
+   newsfile.home_dir = NULL;
+   newsfile.home_scd = NULL;
+   newsfile.subname = "jnewsrc";
+   newsfile.prefix = ".";
+   newsfile.suffix = "";
+   newsfile.mode = M_REGULAR_FILE;
+
+   if ((notnullusercfv (&newsfile)) != -1)
+       Slrn_Newsrc_File = newsfile.result;
+   else
+       Slrn_Newsrc_File = ".jnewsrc";
 #endif
    slrn_message_now ("Using newsrc file %s for server %s.",
 		     Slrn_Newsrc_File, Slrn_Server_Obj->sv_name);
diff -Nru slrn-0.9.6.3/src/userdir.c slrn-0.9.6.3.new/src/userdir.c
--- slrn-0.9.6.3/src/userdir.c	Thu Jan  1 01:00:00 1970
+++ slrn-0.9.6.3.new/src/userdir.c	Mon Sep 18 09:02:06 2000
@@ -0,0 +1,380 @@
+// $Id$
+#include "userdir.h"
+
+static char *nonulhome = "";
+static char variablebuf[MAXPATHLEN];
+
+/******************************************************************************/
+
+char *getvarbydotfile (char *variable, 
+		       char *home_directory)
+{
+    char *p, *var, *retptr;
+    char line[256];
+    char buf[MAXPATHLEN];
+    FILE *cfile;
+
+    *variablebuf = '\0';
+    retptr = NULL;
+    snprintf(buf,  MAXPATHLEN - 1, "%s/%s", home_directory, DOTFILENAME);
+    /* tu niech bada czy jest prawo zapisu dla innych */
+    cfile = fopen (buf, "r");
+    if (cfile == NULL) return (NULL);
+    line[255] = '\0';
+    while (fgets(line, 255, cfile))
+	{
+	if ((p=strchr(line, '#'))) *p = '\0';
+	if ((p=strchr(line, '\n'))) *p = '\0';
+	if (*line == ' ' || *line == '\t')
+	    {
+	    p = line;
+	    do p++;
+	    while (*p != '\0' && (*p == ' ' || *p == '\t'));
+	    if (p == '\0') continue; /* syntax error */
+	    var = p;
+	    }
+	else var = line;
+	if (   (p=strchr(line, ' ')) 
+	    || (p=strchr(line, '\t')) 
+	    || (p=strchr(line, '=')) )
+	    {
+	    *p = '\0';
+	    do p++;
+	    while (   *p != '\0' 
+	           && (   *p == ' ' 
+		       || *p == '\t' 
+		       || *p == '=')
+		  );
+	    if (p == '\0') continue; /* syntax error */
+	    }
+	else continue; /* syntax error */
+	
+	if (!strcmp(var, variable)) /* have got it! */
+	    {
+	    strncpy (variablebuf, p, MAXPATHLEN - 1);
+	    retptr = variablebuf;
+	    break;
+	    }
+	}
+    fclose (cfile);
+#ifdef MAP_FILE_LOOKUP_TO_ENV
+    snprintf(buf, MAXPATHLEN, "%s=%s", variable, retptr);
+    (void) putenv (buf);
+#endif
+    return (retptr);
+}
+
+/******************************************************************************/
+
+int getusercfv(char *variable,
+	       char *home_dir,
+	       char *user_dir,
+	       size_t stringsize)
+{
+    struct stat st;
+    char *d;
+
+    bzero(user_dir, stringsize);
+    if (variable == NULL || *variable == '\0')
+	return (-1);
+    if (home_dir == NULL)
+	home_dir = nonulhome;
+    else
+	{ /* remove last / in home_dir */
+	if ((d = strrchr(home_dir, '/')) && *(d+1) == '\0')
+	    *d = '\0';
+	}
+    d = getenv(variable);    
+    if (d == NULL || *d == '\0') /* don't have variable */
+	{
+	d = getvarbydotfile (variable, home_dir);
+	if (d == NULL || *d == '\0') /* don't have variable */
+	    {
+	    errno = ENOENT;
+	    return (-1);
+	    }
+	}
+    if (*d == '/') {
+	strncpy(user_dir, d, stringsize - 1);
+    } else {
+	snprintf(user_dir, stringsize - 1, "%s/%s", home_dir, d);
+    }
+    if (stat(user_dir, &st) != -1 && S_ISDIR(st.st_mode)) {
+	return (0);
+    }
+    errno = ENOENT;
+    return (-1);
+}
+
+/******************************************************************************/
+
+int detectcfv(struct cfv *CFV)
+{
+    if (CFV->subname == NULL)
+	CFV->subname = nonulhome;
+    if (CFV->home_dir == NULL)
+	CFV->home_dir = getenv("HOME");
+    if (CFV->home_dir == NULL)
+	CFV->home_dir = CFV->home_scd;
+    if (CFV->home_dir == NULL)
+	{
+	errno = ENOENT;
+	return (-1);
+	}
+    return 0;
+}
+
+/******************************************************************************/
+
+int preparemain(struct cfv *CFV)
+{
+    char *p;
+    struct stat st;
+    if ((p = strrchr(CFV->result, '/')) && *(p + 1) == '\0')
+	p = '\0';
+    snprintf((rindex(CFV->result, '\0')), MAXPATHLEN - 1, "/%s",
+	     CFV->subname);
+    if (stat(CFV->result, &st) != -1
+	&& CFV->mode ?
+	S_ISDIR(st.st_mode):
+	S_ISREG(st.st_mode))
+	return (1);
+    return 0;
+}
+
+/******************************************************************************/
+
+int preparehome(struct cfv *CFV)
+{
+    struct stat st;
+
+    if (CFV->home_dir == NULL || *(CFV->home_dir) == '\0')
+	return (-1);
+
+    snprintf(CFV->result, MAXPATHLEN - 1, "%s/%s%s%s",
+	     CFV->home_dir,
+	     CFV->prefix ? CFV->prefix : "",
+	     CFV->subname,
+	     CFV->suffix ? CFV->suffix : "");
+	     
+    if (stat(CFV->result, &st) != -1
+	&& CFV->mode ?
+	S_ISDIR(st.st_mode) :
+	S_ISREG(st.st_mode))	/* have file or dir */
+	return (2);
+
+    return (-1);
+}
+
+/******************************************************************************/
+
+int usercfv(struct cfv *CFV)
+{
+    int gr;
+
+    CFV->athome = 0;
+    gr = detectcfv(CFV);
+    if (gr)
+	return gr;
+
+    /* get environment variable */
+    gr = getusercfv(CFV->variable,
+		    CFV->home_dir,
+		    CFV->result,
+		    MAXPATHLEN);
+		    
+    if (gr != -1) {		/* have main directory + read permission */
+	gr = preparemain(CFV);
+	if (gr && !access(CFV->result, CFV->mode ? X_OK : R_OK))
+	    return 0;
+	}
+    /* don't have main directory or a proper variable set */
+    gr = preparehome(CFV);
+    if (gr == -1) return (-1);
+    if (access(CFV->result, CFV->mode ? X_OK : R_OK))
+	return (-1);
+    CFV->athome = 1;
+    return 1;
+}
+
+/******************************************************************************/
+
+/* If directory or file doesn't exist returns the best one wich may be created */
+int notnullusercfv(struct cfv *CFV)
+{
+    char buf[MAXPATHLEN];
+    int gr;
+    char *p;
+
+    if ((gr = usercfv(CFV)) == -1) {
+	gr = detectcfv(CFV);
+	if (gr)
+	    return gr;		/* remember, it works for errors! */
+	/* get the environment variable */
+	gr = getusercfv(CFV->variable,
+			CFV->home_dir,
+			CFV->result,
+			MAXPATHLEN);
+			
+	(void) preparemain(CFV);
+	strncpy(buf, CFV->result, MAXPATHLEN-1);
+	p = strrchr(buf, '/');
+	if (p) *p = '\0';
+	if (!access(buf, W_OK))
+	    return 0;
+
+	/* don't have main directory or a proper variable set */
+	/* or not enough permissions			      */
+	(void) preparehome(CFV);
+	strncpy(buf, CFV->result, MAXPATHLEN-1);
+	p = strrchr(buf, '/');
+	if (p) *p = '\0';
+	if (access(buf, W_OK))
+	    return (-1);
+	CFV->athome = 1;
+	return 1;
+    }
+    return (gr);
+}
+
+/******************************************************************************/
+
+int chdircfv(struct cfv *CFV)
+{
+    if ((usercfv(CFV)) == -1)
+	return (-1);
+    return ( chdir(CFV->result) );
+}
+
+/******************************************************************************/
+
+int forcechdircfv(struct cfv *CFV, mode_t mode)
+{
+    int ret;
+    
+    ret = chdircfv(CFV);
+    if (ret != -1) 
+	return 0;
+	
+    ret = notnullusercfv(CFV);
+    
+    if (ret != -1) /* have the best location */
+	{
+	ret = mkdir(CFV->result, mode);
+	if (ret == -1) return ret;
+	ret = chdir(CFV->result);
+	if (ret == -1) return ret;
+	return 1;
+	}
+    return (-1);
+}
+
+/******************************************************************************/
+
+int checkfilecfv (struct cfv *CFV, mode_t mode)
+{
+  int fd;
+
+  if ((usercfv(CFV)) != -1)
+      return 1; /* already present! */
+
+  if ((notnullusercfv(CFV)) == -1)
+      return (-1);
+      
+  fd = open (CFV->result, O_CREAT|O_WRONLY|O_APPEND, mode);
+  if (fd == -1)
+      return (-1);
+  close (fd);
+  return (0);
+}
+
+/******************************************************************************/
+
+int checkdircfv (struct cfv *CFV, mode_t mode)
+{
+  if ((usercfv(CFV)) != -1)
+      return 1; /* already present! */
+  if ((notnullusercfv(CFV)) == -1)
+      return (-1);
+  return ( mkdir(CFV->result, mode) );
+}
+
+/******************************************************************************/
+
+int checkoutcfv (struct cfv *CFV, mode_t mode)
+{
+  if (CFV->mode == M_DIRECTORY)
+      return ( checkdircfv (CFV, mode) );
+  return ( checkfilecfv (CFV, mode) );
+}
+
+/******************************************************************************/
+
+FILE *maynullfopencfv(struct cfv * CFV, const char *mode)
+{
+    FILE *cfvfile = NULL;
+
+    if ((usercfv(CFV)) == -1)
+    	{
+	errno = ENOENT;
+	return (NULL);
+	}
+    cfvfile = fopen(CFV->result, mode);
+    return (cfvfile);
+}
+/******************************************************************************/
+
+FILE *notnullfopencfv(struct cfv * CFV, const char *mode)
+{
+    FILE *cfvfile = NULL;
+    
+    if ((notnullusercfv(CFV)) == -1)
+	return (NULL);
+
+    cfvfile = fopen(CFV->result, mode);
+    return (cfvfile);
+}
+
+/******************************************************************************/
+
+FILE *fopencfv(struct cfv * CFV, const char *mode)
+{
+    FILE *cfvfile = NULL;
+
+    if ((strpbrk(mode, "wa")) != NULL)	/* create in best location */
+	cfvfile = notnullfopencfv(CFV, mode);
+    else
+	cfvfile = maynullfopencfv(CFV, mode);
+
+    return (cfvfile);
+}
+
+/******************************************************************************/
+
+DIR *opendircfv (struct cfv * CFV)
+{
+    DIR *cfvdir = NULL;
+
+    if ((usercfv(CFV)) == -1)
+	{
+	errno = ENOENT;
+	return (NULL);
+	}
+    cfvdir = opendir(CFV->result);
+    return (cfvdir);
+}
+
+/******************************************************************************/
+
+void *opencfv(struct cfv * CFV, const char *mode)
+{
+    if (CFV->mode == M_DIRECTORY ||
+        mode == NULL || 
+        *mode == '\0' || 
+	(strchr(mode,'d')) != NULL)
+	return ( (void*) opendircfv (CFV) );
+
+    return ( (void*) fopencfv (CFV, mode) );
+}
+
+/******************************************************************************/
diff -Nru slrn-0.9.6.3/src/userdir.h slrn-0.9.6.3.new/src/userdir.h
--- slrn-0.9.6.3/src/userdir.h	Thu Jan  1 01:00:00 1970
+++ slrn-0.9.6.3.new/src/userdir.h	Mon Sep 18 09:02:06 2000
@@ -0,0 +1,153 @@
+// $Id$
+#ifndef USERDIR__H
+#define USERDIR__H
+
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/param.h>
+#include <errno.h>
+
+#define	M_REGULAR_FILE	0	/* DO NOT SWITCH IT! */
+#define	M_DIRECTORY	1
+#define	DOTFILENAME	".userdir"
+
+/* 
+ * Should I map lookups from .userdir to 
+ * environment variable ???
+ *
+ */
+
+#define	MAP_FILE_LOOKUP_TO_ENV
+
+struct cfv {
+	char result[MAXPATHLEN];	/* our result			*/
+	char *variable;	/* name of an environment variable		*/
+	char *home_dir;	/* home directory or NULL for autodetect	*/
+	char *home_scd; /* directory if home_dir==NULL and no result	*/
+	char *subname;	/* core name of a file/directory		*/
+    	char *prefix;	/* prefix when using directly home_dir		*/
+	char *suffix;	/* suffix when using directly home_dir		*/
+	int mode;	/* expected: M_REGULAR_FILE or M_DIRECTORY	*/
+	unsigned athome:1; /* are we placed inside of home directory?	*/
+	};
+
+/****************** CORE FUNCTIONS  ******************/
+
+/* reads environment variable. if the path isn't absolute will add $HOME/
+ * at the beginning
+ * return: 0 - directory exists
+ *         -1 - directory doesn't exist
+ */
+int getusercfv (char *variable, 
+		    char *home_dir, 
+		    char *user_dir,
+		    size_t stringsize);
+/* reads the $HOME variable */
+int detectcfv(struct cfv *CFV);
+
+/* looks for the config/data file/dir.
+ * result: -1 - error - cannot find file/dir 
+ *         0 - ok
+ *         CFV.result set
+ */
+int usercfv (struct cfv *CFV);
+
+/* looks for the config/data file/dir.
+ * result: -1 - error - cannot read $HOME, not enough create permissions
+ *          0 - ok - if the CFV.result exists, read it. If not - select
+ *                   the best location for creation.
+ *              CFV.result set
+ */              
+int notnullusercfv (struct cfv *CFV);
+
+/************** GENERAL CHECKOUT FUNCTION **************/
+
+/* It tries to open file or directory, and if it doesn't
+ * exists it tries to create it in the best location. 
+ */
+int checkoutcfv (struct cfv *CFV, mode_t mode);
+
+/************* OPENING THE DIRECTORY/FILE **************/
+
+/* opens file or directory using CFV structure
+ *  if (CFV.mode is set to M_DIRECTORY 
+ *  or mode is NULL 
+ *  or mode is set to "" 
+ *  or mode contains 'd' character) -> opendircfv is invoked
+ *  else fopencfv is invoked
+ * result: pointer to DIR or FILE handle (conversion need)
+ */
+void *opencfv(struct cfv * CFV, const char *mode);
+
+/****************** CREATING THE FILE *********************/
+/*   if it doesn't exists				  */
+int checkfilecfv (struct cfv *CFV, mode_t mode);
+
+/*  NOTE:					*/
+/*						*/
+/* Some maynull-like functions specified bellow	*/
+/* can set errno variable to ENOENT if the file	*/
+/* or directory doesn't exists.			*/
+
+/****************** OPENING THE FILE ******************/
+
+/* opens file using CFV and the given mode
+ * after getting name fopen is invoked.
+ * if the given file is considered to be opened for
+ * write it is created.
+ * result: [see fopen(3)]
+ */
+FILE *fopencfv (struct cfv *CFV, const char *mode);
+
+/* opens file using CFV and the given mode
+ * just after getting filename, fopen is invoked
+ * if specified file doesn't exists error is returned
+ * result: [see fopen(3)] or NULL if cannot find the file
+ */
+FILE *maynullfopencfv (struct cfv *CFV, const char *mode);
+
+/* opens file using CFV and the given mode
+ * after getting name fopen is invoked
+ * if the specified file doesn't exists it's created
+ * in the best location
+ * result: [see fopen(3)]
+ */
+FILE *notnullfopencfv (struct cfv *CFV, const char *mode);
+
+/****************** OPENING THE DIRECTORY ****************/
+
+/* opens directory using CFV
+ * after getting name opendir is invoked
+ * result: [see opendir(3)] or NULL if the
+ *         directory doesn't exists
+ */
+DIR *opendircfv (struct cfv * CFV);
+
+/****************** CREATING THE DIRECTORY ****************/
+/*   if it doesn't exists				  */
+
+int checkdircfv (struct cfv *CFV, mode_t mode);
+
+/****************** CHANGING THE DIRECTORY ****************/
+
+/* tries to change current working directory using CFV
+ * after getting name chdir is invoked
+ * result: [see chdir(2)] or -1 if it doesn't exists
+ */
+int chdircfv (struct cfv *CFV);
+
+/* tries to change current working directory using CFV
+ * after getting name chdir is invoked
+ * if the specified directory doesn't exists it's created
+ * result: [see chdir(2)] 
+ */
+int forcechdircfv (struct cfv *CFV, mode_t mode);
+
+#endif
