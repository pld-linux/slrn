diff -cr slrn-0.9.6.3.orig/autoconf/configure.in slrn-0.9.6.3/autoconf/configure.in
*** slrn-0.9.6.3.orig/autoconf/configure.in	Mon Sep 18 00:35:23 2000
--- slrn-0.9.6.3/autoconf/configure.in	Tue Jan  2 20:59:49 2001
***************
*** 29,34 ****
--- 29,35 ----
  netinet/in.h \
  arpa/inet.h \
  sys/utsname.h \
+ sys/time.h \
  locale.h \
  )
  
***************
*** 55,60 ****
--- 56,62 ----
  siglongjmp \
  vsnprintf \
  uname \
+ gettimeofday \
  setlocale \
  isalpha isspace isdigit isalnum ispunct \
  )
diff -cr slrn-0.9.6.3.orig/doc/score.sl slrn-0.9.6.3/doc/score.sl
*** slrn-0.9.6.3.orig/doc/score.sl	Mon Sep 18 00:35:21 2000
--- slrn-0.9.6.3/doc/score.sl	Tue Jan  2 21:09:19 2001
***************
*** 3,13 ****
  % To use this, add the following line to your .jedrc file:
  %    autoload ("score_mode", "score");
  
- % Mode for indenting slrn score files
- 
- % To use this, add the following line to your .jedrc file:
- %    autoload ("score_mode", "score");
- 
  % Align the ':' characters in the same column
  define score_indent_line ()
  {
--- 3,8 ----
***************
*** 59,65 ****
  define_syntax ("-0-9", '0', $1);	% Numbers
  define_syntax ('[', '#', $1);
  
! () = define_keywords ($1, "From:Xref:", 5);
  () = define_keywords ($1, "Lines:Score:", 6);
  () = define_keywords ($1, "Score::", 7);
  () = define_keywords ($1, "Expires:Subject:", 8);
--- 54,61 ----
  define_syntax ("-0-9", '0', $1);	% Numbers
  define_syntax ('[', '#', $1);
  
! () = define_keywords ($1, "Age:", 4);
! () = define_keywords ($1, "Date:From:Xref:", 5);
  () = define_keywords ($1, "Lines:Score:", 6);
  () = define_keywords ($1, "Score::", 7);
  () = define_keywords ($1, "Expires:Subject:", 8);
diff -cr slrn-0.9.6.3.orig/doc/score.txt slrn-0.9.6.3/doc/score.txt
*** slrn-0.9.6.3.orig/doc/score.txt	Mon Sep 18 00:35:21 2000
--- slrn-0.9.6.3/doc/score.txt	Tue Jan  2 21:09:19 2001
***************
*** 12,20 ****
        * Xref
        * References
        * Lines
!       
! as well as the newsgroup that the article is part of.
!   
  Score file format:
  
    The format of the file is very simple (See below for an explicit
--- 12,23 ----
        * Xref
        * References
        * Lines
!       * Message-Id
!       * Date
! 
! as well as the two special keywords "Newsgroup" (the newsgroup that the
! article is part of) and "Age" (the age of the article in days).
! 
  Score file format:
  
    The format of the file is very simple (See below for an explicit
***************
*** 59,67 ****
  MM/DD/YYYY or DD-MM-YYYY.  Note: DO NOT CONFUSE THIS WITH THE EXPIRES HEADER
  KEYWORD.
  
! The Lines keyword is also special.  Its value is not a regular expression,
! rather, a simple integer.  It may be used to kill articles which contain too
! many or too few lines.  For example,
  
      Score: -100
      Lines: 1000
--- 62,72 ----
  MM/DD/YYYY or DD-MM-YYYY.  Note: DO NOT CONFUSE THIS WITH THE EXPIRES HEADER
  KEYWORD.
  
! The Lines and Age keywords are also special.  Their value is not a regular
! expression, rather, a simple integer.
! 
! "Lines" may be used to kill articles which contain too many or too few
! lines.  For example,
  
      Score: -100
      Lines: 1000
***************
*** 73,78 ****
--- 78,92 ----
      ~Lines: 3
      
  assigns a score to articles that have less than or equal to 3 lines.
+ 
+ "Age" can be used to score articles which are younger than N days. For
+ example,
+ 
+     Score: 10
+     Age: 7
+ 
+ adds 10 points to the score of each article that is at most one week old.
+ You can use negation (`~') to score articles that are older than N days.
  
  Finally a score file may include other score files via the `include'
  statement.  The syntax is simple:
diff -cr slrn-0.9.6.3.orig/doc/slrn.1 slrn-0.9.6.3/doc/slrn.1
*** slrn-0.9.6.3.orig/doc/slrn.1	Mon Sep 18 00:35:21 2000
--- slrn-0.9.6.3/doc/slrn.1	Tue Jan  2 21:09:19 2001
***************
*** 904,913 ****
   % a >, <, :, |, or = character is a quoted line.
   ignore_quotes "^ ? ?[><:=|]"
  
!  % This sets the follow-up and reply strings.  Here, the following format
!  % specifiers are recognized:
!  %    %d:date, %r:real name, %f:email address, %s:subject,
!  %    %m:msgid, %n:newsgroups, %%: percent
   set followup_string "On %d, %r <%f> wrote:"
   set reply_string "In %n, you wrote:"
  
--- 904,913 ----
   % a >, <, :, |, or = character is a quoted line.
   ignore_quotes "^ ? ?[><:=|]"
  
!  % This sets the follow-up and reply strings.  Here, the following format 
!  % specifiers are recognized: 
!  %    %d:date, %D:date (as defined by followup_date_format) %r:real name,
!  %    %f:email address, %s:subject, %m:msgid, %n:newsgroups, %%: percent 
   set followup_string "On %d, %r <%f> wrote:"
   set reply_string "In %n, you wrote:"
  
***************
*** 945,950 ****
--- 945,951 ----
   %	l : Number of lines
   %	n : server number
   %	d : date
+  %	D : date (as defined by overview_date_format)
   %	t : thread tree
   %	F : flags (read/unread, `*' and `#' tags, header number)
   %	% : percent character
***************
*** 956,961 ****
--- 957,979 ----
   header_display_format 3 "%F%-5S%-5l:%t%50s %r"
   header_display_format 4 "%F%-5S [%10r]:%t%49s %-19g[%17d]"
  
+  % Used as the format string for dates in header_display_format. The syntax is
+  % identical to the one of strftime(3)
+  set followup_date_format "%a, %d %b %Y at %H:%M GMT"
+  
+  % Used as the format string for dates in followup_string and reply_string
+  set overview_date_format "%d %b %y %H:%M"
+    
+  % If non-zero, dates printed by the above format strings will be converted to
+  % the user's local timezone. Please note that this will not affect the "Date:"
+  % header lines in your own postings as they are not created by slrn.
+  set use_localtime 0
+  
+  % This variable can be set to a ``locale'' which will be used by the above
+  % format strings. E.g. you could set it to "de_DE" to get German names for
+  % days and months when posting to de.*. "C" is for "standard English".
+  set date_locale "C"
+  
   % WWW browser to use.  The 'U' key in article mode searches the current article
   % for a URL and then calls X browser if slrn appears to be run in X windows
   % and non_Xbrowser otherwise.  Note: The second Xbrowser form assumes that
diff -cr slrn-0.9.6.3.orig/doc/slrn.rc slrn-0.9.6.3/doc/slrn.rc
*** slrn-0.9.6.3.orig/doc/slrn.rc	Mon Sep 18 00:35:21 2000
--- slrn-0.9.6.3/doc/slrn.rc	Tue Jan  2 21:09:19 2001
***************
*** 26,37 ****
--- 26,49 ----
  % Name of signature file to use.  If "", then do not add signature.
  %set signature ".signature"
  
+ % In some groups, it is common to have a "named signoff" before the signature.
+ %set signoff_string "Cu\n John Doe"
+ 
  % The quote string will be used when following up/replying
  set quote_string ">"
  
+ % If non-zero, a space will be added between quote_string and lines that
+ % were not yet quoted. You may find this more readable.
+ set smart_quote 0
+ 
  % If non-zero, signature will not be included in quoted text of followups
  set followup_strip_signature 0
  
+ % Defines the regular expression slrn will use to remove old subjects
+ % (usually indicated by "(was: ...)") when writing followups. Set to "" to
+ % turn this feature off.
+ %set strip_was_regexp "(was:.*) *$"
+   
  % If set to 1, slrn will not allow you to post articles that contain 
  % non-quoted lines whose length exceeds 80 characters.  If set to 2, a warning
  % will be generated.
***************
*** 44,67 ****
  
  % This sets the follow-up and reply strings.  Here, the following format 
  % specifiers are recognized: 
! %    %d:date, %r:real name, %f:email address, %s:subject,
! %    %m:msgid, %n:newsgroups, %%: percent 
  set followup_string "On %d, %r <%f> wrote:"
  set reply_string "In %n, you wrote:"
  
  %Custom headers to add to NEW posts
  %set custom_headers "X-Whatever: bla\nX-Misc: bla bla"
  
! % Custom headers for followup/reply.  These can use format specifiers as
! % in the 'followup' string variable.
  %set followup_custom_headers "X-newsgroup: %n\nX-realname: %r\n"
  %set reply_custom_headers "X-newsgroup: %n\nX-realname: %r\n"
  
  % Headers to show when viewing an articles.  This is a comma-separated
  % list of strings that specify what headers to show.  Note that these 
  % strings are not regular expressions.  However, one may use, e.g.,
  % "X-" to match any header beginning with "X-".  Similarly, "F" will 
  % match "From:" and "Followup".
  visible_headers "From:,Subject:,Newsgroups:,Followup-To:,Reply-To:"
  
  % Setting the header window display format.
--- 56,82 ----
  
  % This sets the follow-up and reply strings.  Here, the following format 
  % specifiers are recognized: 
! %    %d:date, %D:date (as defined by followup_date_format) %r:real name,
! %    %f:email address, %s:subject, %m:msgid, %n:newsgroups, %%: percent 
  set followup_string "On %d, %r <%f> wrote:"
  set reply_string "In %n, you wrote:"
  
  %Custom headers to add to NEW posts
  %set custom_headers "X-Whatever: bla\nX-Misc: bla bla"
  
! % Custom headers for followup/reply/supersedes.  These can use format
! % specifiers as in the 'followup' string variable.
  %set followup_custom_headers "X-newsgroup: %n\nX-realname: %r\n"
  %set reply_custom_headers "X-newsgroup: %n\nX-realname: %r\n"
+ %set supersedes_custom_headers "X-Superseded-Date: %d\n"
  
  % Headers to show when viewing an articles.  This is a comma-separated
  % list of strings that specify what headers to show.  Note that these 
  % strings are not regular expressions.  However, one may use, e.g.,
  % "X-" to match any header beginning with "X-".  Similarly, "F" will 
  % match "From:" and "Followup".
+ % To exclude a certain header, precede it with "!". Of multiple matching
+ % entries, the last one decides whether a header is displayed.
  visible_headers "From:,Subject:,Newsgroups:,Followup-To:,Reply-To:"
  
  % Setting the header window display format.
***************
*** 83,88 ****
--- 98,104 ----
  %	l : Number of lines
  %	n : server number
  %	d : date
+ %	D : date (as defined by overview_date_format)
  %	t : thread tree
  %	F : flags (read/unread, `*' and `#' tags, header number)
  %	% : percent character
***************
*** 94,99 ****
--- 110,132 ----
  header_display_format 3 "%F%-5S%-5l:%t%50s %r"
  header_display_format 4 "%F%-5S [%10r]:%t%49s %-19g[%17d]"
  
+ % Used as the format string for dates in header_display_format. The syntax is
+ % identical to the one of strftime(3)
+ set followup_date_format "%a, %d %b %Y at %H:%M GMT"
+ 
+ % Used as the format string for dates in followup_string and reply_string
+ set overview_date_format "%d %b %y %H:%M"
+   
+ % If non-zero, dates printed by the above format strings will be converted to
+ % the user's local timezone. Please note that this will not affect the "Date:"
+ % header lines in your own postings as they are not created by slrn.
+ set use_localtime 0
+ 
+ % This variable can be set to a ``locale'' which will be used by the above
+ % format strings. E.g. you could set it to "de_DE" to get German names for
+ % days and months when posting to de.*. "C" is for "standard English".
+ set date_locale "C"
+ 
  % WWW browser to use.  The 'U' key in article mode searches the current article
  % for a URL and then calls X browser if slrn appears to be run in X windows
  % and non_Xbrowser otherwise.  Note: The second Xbrowser form assumes that
***************
*** 135,140 ****
--- 168,176 ----
  % If non-zero, slrn will draw the thread tree using simple ascii characters
  set simulate_graphic_chars 0
  
+ % If non-zero, a clock is shown at the upper-statusline.
+ set clock_in_top_status_line 0
+ 
  % Enable xterm/win32 mouse support: 1 to enable, 0 to disable
  set mouse 0
  
***************
*** 171,176 ****
--- 207,217 ----
  set cc_followup 0
  set cc_followup_string "[This message has also been posted.]"
  
+ % If 0, slrn won't warn on Followup-to's
+ % if 1, slrn warns only if the Followup-to doesn't go to the current Newsgroup
+ % if 2, slrn will warn on every Followup-to
+ set warn_followup_to 0
+ 
  % Set to 0 to turn off display of ~ at end of article
  set use_tilde 1
  
***************
*** 188,193 ****
--- 229,237 ----
  % it implements the same interface as sendmail!
  %set sendmail_command "/usr/lib/sendmail -oi -t -oem -odb"
  
+ % If non-zero also add the content of the postings 'To:' header to the
+ % replies 'To:' header
+ set use_to_on_reply 1
  
  % Name of score file  (relative to HOME directory)
  %scorefile "News/Score"
***************
*** 199,204 ****
--- 243,252 ----
  set max_low_score 0
  set kill_score -9999
  
+ % If non-zero, zero scores are shown in the headerfields.
+ % A zero value makes the screen look less busy.
+ set display_zero_score 0
+ 
  % Name of directory where decoded files are placed (relative to HOME)
  set decode_directory "News"
  % Directory where all other files are saved.
***************
*** 263,268 ****
--- 311,322 ----
  % wrapped.
  set wrap_flags 4
  
+ % How to wrap lines?
+ %  0 ==> wrap on word boundaries (words longer than line length are not wrapped)
+ %  1 ==> wrap at right border (regardless of word boundaries)
+ %  2 ==> try to wrap on word boundaries, or else wrap at right border
+ set wrap_method 2
+ 
  % Maximum number of articles to read before slrn will prompt.  Default is 100.
  % Set this to zero to turn of prompting.
  set query_read_group_cutoff 100
***************
*** 380,385 ****
--- 434,449 ----
  %---------------------------------------------------------------------------
  % Colors
  %---------------------------------------------------------------------------
+ 
+ % If non-zero, the score is printed in color, depending on its value
+ set color_score_by_score 1
+ 
+ % If non-zero, the subject is printed in color, depending on the score
+ set color_subject_by_score 1
+ 
+ % If non-zero, the subjects of unread articles are highlighted
+ set highlight_unread_subjects 1
+ 
  color article		"lightgray"	"black"
  color author		"magenta"	"black"
  color boldtext		"brightblue"	"black"
***************
*** 394,399 ****
--- 458,465 ----
  color header_name	"green"		"black"
  color header_number	"green"		"black"
  color headers		"brightcyan"	"black"
+ color neg_score		"green"		"black"
+ color pos_score		"blue"		"black"
  color high_score	"red"		"black"
  color italicstext	"magenta"	"black"
  color menu		"yellow"	"blue"
Only in slrn-0.9.6.3/doc: slrn.rc.orig
diff -cr slrn-0.9.6.3.orig/doc/slrnfuns.txt slrn-0.9.6.3/doc/slrnfuns.txt
*** slrn-0.9.6.3.orig/doc/slrnfuns.txt	Mon Sep 18 00:35:21 2000
--- slrn-0.9.6.3/doc/slrnfuns.txt	Tue Jan  2 21:09:19 2001
***************
*** 1396,1401 ****
--- 1396,1424 ----
     getkey
  --------------------------------------------------------------
  
+ datestring_to_unixtime
+ 
+  SYNOPSIS
+    -
+ 
+  USAGE
+    Integer datestring_to_unixtime (String date)
+ 
+  DESCRIPTION
+    This function converts the date string `date' (in any format commonly
+    used in "Date:" header lines) to an integer value, giving the number of
+    seconds since 00:00:00 GMT, January 1, 1970.
+ 
+  EXAMPLE
+    The following function returns the date of the currently selected header
+    as seconds since the Epoch:
+    
+         define get_article_time ()
+         { 
+    	    return datestring_to_unixtime(extract_article_header("Date"));
+         }
+ --------------------------------------------------------------
+ 
  get_variable_value
  
   SYNOPSIS
diff -cr slrn-0.9.6.3.orig/doc/tm/slrnfuns/misc.tm slrn-0.9.6.3/doc/tm/slrnfuns/misc.tm
*** slrn-0.9.6.3.orig/doc/tm/slrnfuns/misc.tm	Mon Sep 18 00:35:22 2000
--- slrn-0.9.6.3/doc/tm/slrnfuns/misc.tm	Tue Jan  2 21:09:19 2001
***************
*** 1,3 ****
--- 1,20 ----
+ \function{datestring_to_unixtime}
+ \synopsis{-}
+ \usage{Integer datestring_to_unixtime (String date)}
+ \description
+    This function converts the date string \var{date} (in any format commonly
+    used in "Date:" header lines) to an integer value, giving the number of
+    seconds since 00:00:00 GMT, January 1, 1970.
+ \example
+    The following function returns the date of the currently selected header
+    as seconds since the Epoch:
+    
+         define get_article_time ()
+         { 
+ 	    return datestring_to_unixtime(extract_article_header("Date"));
+         }
+ \done
+ 
  \function{get_variable_value}
  \synopsis{-}
  \usage{Value get_variable_value (String v)}
diff -cr slrn-0.9.6.3.orig/macros/ispell.sl slrn-0.9.6.3/macros/ispell.sl
*** slrn-0.9.6.3.orig/macros/ispell.sl	Mon Sep 18 00:35:23 2000
--- slrn-0.9.6.3/macros/ispell.sl	Tue Jan  2 20:59:41 2001
***************
*** 3,9 ****
  %static
  define ispell_file (file)
  {
!    variabe cmd = "ispell -x";
     () = system (sprintf ("%s '%s'", cmd, file));
  }
  
--- 3,9 ----
  %static
  define ispell_file (file)
  {
!    variable cmd = "ispell -x";
     () = system (sprintf ("%s '%s'", cmd, file));
  }
  
diff -cr slrn-0.9.6.3.orig/src/Makefile.g32 slrn-0.9.6.3/src/Makefile.g32
*** slrn-0.9.6.3.orig/src/Makefile.g32	Mon Sep 18 00:35:25 2000
--- slrn-0.9.6.3/src/Makefile.g32	Tue Jan  2 21:09:19 2001
***************
*** 165,171 ****
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrndir.o slrndir.c
  $(OBJDIR)/slrnpull.o: slrnpull.c config.h slrnfeat.h jdmacros.h ttymsg.h \
                   util.h sltcp.h nntplib.h nntpcodes.h score.c art.h xover.h \
!                  score.h xover.c hash.h hash.c
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrnpull.o slrnpull.c
  $(OBJDIR)/sltcp.o: sltcp.c config.h sltcp.h
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/sltcp.o sltcp.c
--- 165,171 ----
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrndir.o slrndir.c
  $(OBJDIR)/slrnpull.o: slrnpull.c config.h slrnfeat.h jdmacros.h ttymsg.h \
                   util.h sltcp.h nntplib.h nntpcodes.h score.c art.h xover.h \
!                  score.h xover.c hash.h hash.c sortdate.c
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrnpull.o slrnpull.c
  $(OBJDIR)/sltcp.o: sltcp.c config.h sltcp.h
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/sltcp.o sltcp.c
diff -cr slrn-0.9.6.3.orig/src/Makefile.in slrn-0.9.6.3/src/Makefile.in
*** slrn-0.9.6.3.orig/src/Makefile.in	Mon Sep 18 00:35:26 2000
--- slrn-0.9.6.3/src/Makefile.in	Tue Jan  2 21:09:19 2001
***************
*** 105,111 ****
  chkslang_O_DEP = config.h Makefile
  version_O_DEP = version.h
  
! slrnpull_O_DEP = score.c xover.c hash.c version.h
  slrnpull_DEPS = $(OBJDIR)/util.o $(OBJDIR)/ttymsg.o \
   $(OBJDIR)/sltcp.o $(OBJDIR)/nntplib.o $(OBJDIR)/slrndir.o
  
--- 105,111 ----
  chkslang_O_DEP = config.h Makefile
  version_O_DEP = version.h
  
! slrnpull_O_DEP = sortdate.c score.c xover.c hash.c version.h
  slrnpull_DEPS = $(OBJDIR)/util.o $(OBJDIR)/ttymsg.o \
   $(OBJDIR)/sltcp.o $(OBJDIR)/nntplib.o $(OBJDIR)/slrndir.o
  
***************
*** 140,146 ****
  clean:
  	/bin/rm -f $(OBJDIR)/* *~
  distclean: clean
! 	/bin/rm -rf $(OBJDIR) Makefile sysconf.h
  installdirs:
  	$(MKINSDIR) $(DEST_DOCDIR)
  	$(MKINSDIR) $(DEST_DOCDIR)/slrnpull
--- 140,146 ----
  clean:
  	/bin/rm -f $(OBJDIR)/* *~
  distclean: clean
! 	/bin/rm -rf $(OBJDIR) Makefile sysconf.h config.h
  installdirs:
  	$(MKINSDIR) $(DEST_DOCDIR)
  	$(MKINSDIR) $(DEST_DOCDIR)/slrnpull
diff -cr slrn-0.9.6.3.orig/src/Makefile.os2 slrn-0.9.6.3/src/Makefile.os2
*** slrn-0.9.6.3.orig/src/Makefile.os2	Mon Sep 18 00:35:25 2000
--- slrn-0.9.6.3/src/Makefile.os2	Tue Jan  2 21:09:19 2001
***************
*** 188,194 ****
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrndir.o slrndir.c
  $(OBJDIR)/slrnpull.o: slrnpull.c config.h slrnfeat.h jdmacros.h ttymsg.h \
                   util.h sltcp.h nntplib.h nntpcodes.h score.c art.h xover.h \
!                  score.h xover.c hash.h hash.c
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrnpull.o slrnpull.c
  $(OBJDIR)/sltcp.o: sltcp.c config.h sltcp.h
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/sltcp.o sltcp.c
--- 188,194 ----
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrndir.o slrndir.c
  $(OBJDIR)/slrnpull.o: slrnpull.c config.h slrnfeat.h jdmacros.h ttymsg.h \
                   util.h sltcp.h nntplib.h nntpcodes.h score.c art.h xover.h \
!                  score.h xover.c hash.h hash.c sortdate.c
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/slrnpull.o slrnpull.c
  $(OBJDIR)/sltcp.o: sltcp.c config.h sltcp.h
  	$(CC) -c $(CFLAGS) -o $(OBJDIR)/sltcp.o sltcp.c
diff -cr slrn-0.9.6.3.orig/src/VMSMAKE.COM slrn-0.9.6.3/src/VMSMAKE.COM
*** slrn-0.9.6.3.orig/src/VMSMAKE.COM	Mon Sep 18 00:35:30 2000
--- slrn-0.9.6.3/src/VMSMAKE.COM	Tue Jan  2 21:15:28 2001
***************
*** 1,4 ****
! $ SLRN_VERSION = "0.9.6.2"
  $ SLANG_VERSION =  10003
  $! Modified VMSMAKE for SLRN - Andy Harper, Kings College London
  $!                             Martin Zinser, GSI Darmstadt
--- 1,4 ----
! $ SLRN_VERSION = "0.9.6.3pl4"
  $ SLANG_VERSION =  10003
  $! Modified VMSMAKE for SLRN - Andy Harper, Kings College London
  $!                             Martin Zinser, GSI Darmstadt
diff -cr slrn-0.9.6.3.orig/src/art.c slrn-0.9.6.3/src/art.c
*** slrn-0.9.6.3.orig/src/art.c	Mon Sep 18 00:35:28 2000
--- slrn-0.9.6.3/src/art.c	Tue Jan  2 21:09:49 2001
***************
*** 31,36 ****
--- 31,40 ----
  # include <unistd.h>
  #endif
  
+ #ifdef HAVE_SYS_TIME_H
+ # include <sys/time.h>
+ #endif
+ 
  #ifdef HAVE_STDLIB_H
  # include <stdlib.h>
  #endif
***************
*** 82,87 ****
--- 86,96 ----
  char *Slrn_Art_Help_Line;
  char *Slrn_Followup_Custom_Headers;
  char *Slrn_Reply_Custom_Headers;
+ char *Slrn_Supersedes_Custom_Headers;
+ char *Slrn_Strip_Was_Regexp;
+ char *Slrn_Overview_Date_Format;
+ char *Slrn_Followup_Date_Format;
+ 
  
  int Slrn_Emphasized_Text_Mode = 3;
  #define EMPHASIZE_ARTICLE       1
***************
*** 103,115 ****
--- 112,130 ----
  int Slrn_Query_Next_Article = 1;
  int Slrn_Query_Next_Group = 1;
  int Slrn_Auto_CC_To_Poster = 0;
+ int Slrn_Send_To_To = 1;
  int Slrn_Score_After_XOver;
  int Slrn_Use_Tmpdir = 0;
  int Slrn_Threads_Visible = 0;
  int Slrn_Use_Header_Numbers = 1;
+ int Slrn_Warn_Followup_To = 0;
  #if SLRN_HAS_SORT_BY_SCORE
  int Slrn_Display_Score;
+ int Slrn_Display_Zero_Score = 0;
+ int Slrn_Color_Score = 1;
+ int Slrn_Color_Subject = 1;
  #endif
+ int Slrn_Highlight_Unread = 1;
  int Slrn_High_Score_Min = 1;
  int Slrn_Low_Score_Max = 0;
  int Slrn_Kill_Score_Max = -9999;
***************
*** 249,254 ****
--- 264,315 ----
  #endif
  /*}}}*/
  
+ /*{{{ portability functions */
+ #ifndef HAVE_SYS_TIME_H
+ #ifndef HAVE_GETTIMEOFDAY
+ #ifdef VMS
+ #define HAVE_GETTIMEOFDAY
+ struct timeval { long tv_sec; long tv_usec;};
+ 
+ void gettimeofday(struct timeval* z, void* ignored)
+ {
+ 	unsigned long tod[2];
+ 	SYS$GETTIM(tod);
+ 	
+ 	z->tv_sec=( (tod[0]/10000000) + ((tod[1]* 429 )&0x7fffffffl) );
+ 	z->tv_usec=((tod[0]/10)%1000000);
+ }
+ #endif
+ #ifdef WIN32
+ #define HAVE_GETTIMEOFDAY
+ long GetTickCount();
+ struct timeval { long tick_count; };
+ 
+ static int timegettime(struct timeval* timestruct , void* ignored)
+ {
+ 	timestruct->tick_count = GetTickCount(); /* Simplest win32 call you'll ever see */
+ }
+ #endif
+ #endif
+ #endif
+ 
+ #ifdef HAVE_GETTIMEOFDAY
+ #ifdef WIN32
+ /* Return time differences in microseconds */
+ unsigned long time_diff(struct timeval t1, struct timeval t2)
+ {
+ 	return (t1.tick_count - t2.tick_count)*1000;
+ }
+ #else /* Proper UNIX! (or VMS) */
+ /* Return time differences in microseconds */
+ unsigned long time_diff(struct timeval t1, struct timeval t2)
+ {
+ 	return (t1.tv_sec - t2.tv_sec)*1000000 + (t1.tv_usec - t2.tv_usec);
+ }
+ #endif
+ #endif
+ /*}}}*/
+ 
  /*{{{ utility functions */
  
  static char *map_char_to_string (int ch) /*{{{*/
***************
*** 1862,1867 ****
--- 1923,1934 ----
     int num_lines_update;
     int status;
  
+ #ifdef HAVE_GETTIMEOFDAY
+    double current_bps;
+    struct timeval start_time, new_time;
+    gettimeofday(&start_time, NULL);
+ #endif
+    
     last_header_showing = Header_Showing;
     
     if ((Header_Showing == h)
***************
*** 1879,1885 ****
     if (h->tag_number) slrn_message_now ("#%2d/%-2d: Retrieving... %s", 
  				    h->tag_number, Num_Tag_List.len, 
  				    h->subject);
!    else slrn_message_now ("[%d]Reading...", h->number);
  
     status = Slrn_Server_Obj->sv_select_article (n, h->msgid);
     if (status != OK_ARTICLE)
--- 1946,1952 ----
     if (h->tag_number) slrn_message_now ("#%2d/%-2d: Retrieving... %s", 
  				    h->tag_number, Num_Tag_List.len, 
  				    h->subject);
!    else slrn_message_now ("[%d] Reading...", h->number);
  
     status = Slrn_Server_Obj->sv_select_article (n, h->msgid);
     if (status != OK_ARTICLE)
***************
*** 1892,1898 ****
  
  	slrn_error ("Article %d unavailable.", n);
  	
! 	if (kill_refs && ((h->flags & HEADER_READ) == 0))
  	  {
  	     kill_cross_references (h);
  	     h->flags |= HEADER_READ;
--- 1959,1966 ----
  
  	slrn_error ("Article %d unavailable.", n);
  	
! 	if (kill_refs && ((h->flags & HEADER_READ) == 0) &&
! 	    ((h->flags & HEADER_TAGGED) == 0))
  	  {
  	     kill_cross_references (h);
  	     h->flags |= HEADER_READ;
***************
*** 1923,1928 ****
--- 1991,2000 ----
  
     cline = NULL;
     total_lines = 0;
+ 
+    /* Reset byte counter */
+    Slrn_Server_Obj->sv_nntp_bytes(1);
+    
     while (1)
       {
  	status = Slrn_Server_Obj->sv_read_line(buf, sizeof(buf));
***************
*** 1947,1959 ****
  	     */
  	    && (total_lines < (unsigned int) h->lines))
  	  {
  	     if (h->tag_number)
  	       slrn_message_now ("#%2d/%-2d: Read %4d/%-4d lines (%s)",
  				 h->tag_number, Num_Tag_List.len,
  				 total_lines, h->lines, h->subject);
  	     else
! 	       slrn_message_now ("[%d]Read %d/%d lines so far...", 
  				 h->number, total_lines, h->lines);
  	  }
  	
  	len = strlen (buf);
--- 2019,2046 ----
  	     */
  	    && (total_lines < (unsigned int) h->lines))
  	  {
+ #ifdef HAVE_GETTIMEOFDAY
+ 	     gettimeofday(&new_time, NULL);
+ 	     current_bps = time_diff(new_time, start_time)/1000000.0;
+ 	     if (current_bps > 0)
+ 		current_bps = (Slrn_Server_Obj->sv_nntp_bytes(0) / 1024)/current_bps;
+ #endif
  	     if (h->tag_number)
+ #ifdef HAVE_GETTIMEOFDAY
+ 	       slrn_message_now ("#%2d/%-2d: Read %4d/%-4d lines (%s) at %.2fkB/sec",
+ 				 h->tag_number, Num_Tag_List.len, total_lines,
+ 				 h->lines, h->subject, current_bps);
+ 	     else
+ 	       slrn_message_now ("[%d] Read %d/%d lines so far at %.2fkB/sec", 
+ 				 h->number, total_lines, h->lines, current_bps);
+ #else
  	       slrn_message_now ("#%2d/%-2d: Read %4d/%-4d lines (%s)",
  				 h->tag_number, Num_Tag_List.len,
  				 total_lines, h->lines, h->subject);
  	     else
! 	       slrn_message_now ("[%d] Read %d/%d lines so far...", 
  				 h->number, total_lines, h->lines);
+ #endif
  	  }
  	
  	len = strlen (buf);
***************
*** 2026,2032 ****
     /* Only now may the article be said to be the current article */
     Slrn_Current_Article = a;
      
!    if (kill_refs && ((h->flags & HEADER_READ) == 0))
       {
  	kill_cross_references (h);
  	h->flags |= HEADER_READ;
--- 2113,2120 ----
     /* Only now may the article be said to be the current article */
     Slrn_Current_Article = a;
      
!    if (kill_refs && ((h->flags & HEADER_READ) == 0) &&
!        ((h->flags & HEADER_TAGGED) == 0))
       {
  	kill_cross_references (h);
  	h->flags |= HEADER_READ;
***************
*** 2139,2144 ****
--- 2227,2233 ----
  int slrn_insert_followup_format (char *f, FILE *fp) /*{{{*/
  {
     char ch, *s, *smax;
+    char buf[128];
     
     if (f == NULL)
       return 0;
***************
*** 2182,2187 ****
--- 2271,2289 ----
  	   case 'd':
  	     s = Slrn_Current_Header->date;
  	     break;
+ 	   case 'D':
+ 	       {
+ 		  char *fmtstr;
+ 		  
+ 		  fmtstr = Slrn_Followup_Date_Format;
+ 		  if (fmtstr == NULL)
+ 		    fmtstr = "%a, %d %b %Y at %H:%M GMT";
+ 		  
+ 		  slrn_strftime(buf, sizeof(buf), fmtstr,
+ 				Slrn_Current_Header->date);
+ 		  s = buf;
+ 	       }
+ 	     break;
  	   case '%':
  	   default:
  	     putc (ch, fp);
***************
*** 2229,2234 ****
--- 2331,2359 ----
  }
  #endif
  
+ /* This function strips the old subject included with "(was: <old sub>)"
+  * from the new subject */
+ 
+ static void strip_subject_was(char *subject)
+ {
+    if (*Slrn_Strip_Was_Regexp)
+      {
+ 	SLRegexp_Type re;
+ 	unsigned char compiled_pattern_buf[256];
+ 	unsigned char *was;
+ 	
+ 	re.pat = (unsigned char *) Slrn_Strip_Was_Regexp;
+ 	re.buf = compiled_pattern_buf;
+ 	re.case_sensitive = 0;
+ 	re.buf_len = sizeof (compiled_pattern_buf);
+ 	
+ 	(void) SLang_regexp_compile (&re);
+ 	if (NULL != (was = SLang_regexp_match ((unsigned char *) subject,
+ 					       strlen (subject), &re)))
+ 	  *was = '\0';
+      }
+ }
+ 
  /* If from != NULL, it's taken as the address to send the reply to, otherwise
   * the reply address is taken from Reply-To: or From: */
  static void reply (char *from) /*{{{*/
***************
*** 2238,2243 ****
--- 2363,2369 ----
     FILE *fp;
     char file[256];
     unsigned int n;
+    char *quote_str;
  
     if (-1 == slrn_check_batch ())
       return;
***************
*** 2284,2290 ****
     subject = slrn_skip_whitespace (subject);
     if (0 == slrn_case_strncmp ((unsigned char *)"Re:", (unsigned char *)subject, 3))
       subject = slrn_skip_whitespace (subject + 3);
! 
     to = slrn_extract_header ("To: ", 4);
  
     n = 0;
--- 2410,2420 ----
     subject = slrn_skip_whitespace (subject);
     if (0 == slrn_case_strncmp ((unsigned char *)"Re:", (unsigned char *)subject, 3))
       subject = slrn_skip_whitespace (subject + 3);
!    
!    /* We need a copy of subject as strip_subject_was() might change it */
!    subject = slrn_safe_strmalloc (subject);
!    strip_subject_was(subject);
!    
     to = slrn_extract_header ("To: ", 4);
  
     n = 0;
***************
*** 2292,2301 ****
     if (from != NULL)
       {
  	fputs (from, fp);
! 	if (to != NULL)
  	  fputs (", ", fp);
       }
!    if (to != NULL)
       fputs (to, fp);
  
     fputs ("\n", fp); 
--- 2422,2431 ----
     if (from != NULL)
       {
  	fputs (from, fp);
! 	if (to != NULL && Slrn_Send_To_To)
  	  fputs (", ", fp);
       }
!    if (to != NULL && Slrn_Send_To_To)
       fputs (to, fp);
  
     fputs ("\n", fp); 
***************
*** 2348,2364 ****
  	if (l != NULL) l = l->next;
       }
     
     while (l != NULL)
       {
! 	fprintf (fp, "%s%s\n", 
! 		 ((Slrn_Quote_String == NULL) ? ">" : Slrn_Quote_String), 
! 		 l->buf);
  	l = l->next;
       }
     slrn_add_signature (fp);
     slrn_fclose (fp);
     
     slrn_mail_file (file, 1, n, from, subject);
     if (Slrn_Use_Tmpdir) (void) slrn_delete_file (file);
  }
  
--- 2478,2497 ----
  	if (l != NULL) l = l->next;
       }
     
+    if (NULL == (quote_str = Slrn_Quote_String))
+      quote_str = ">";
+ 
     while (l != NULL)
       {
! 	int smart_space = Slrn_Smart_Quote && ! (l->flags & QUOTE_LINE);
! 	fprintf (fp, "%s%s%s\n", quote_str, (smart_space)? " " : "" , l->buf);
  	l = l->next;
       }
     slrn_add_signature (fp);
     slrn_fclose (fp);
     
     slrn_mail_file (file, 1, n, from, subject);
+    slrn_free(subject);
     if (Slrn_Use_Tmpdir) (void) slrn_delete_file (file);
  }
  
***************
*** 2462,2473 ****
--- 2595,2608 ----
  static void followup (void) /*{{{*/
  {
     char *msgid, *newsgroups, *subject, *xref, *quote_str, *cc_address;
+    char *followupto=NULL, *was;
     Slrn_Article_Line_Type *l;
     FILE *fp;
     char file [SLRN_MAX_PATH_LEN];
     unsigned int n;
     int prefix_arg;
     int perform_cc;
+    int rsp;
  #if SLRN_HAS_SLANG
     int free_cc_string = 0;
  #endif
***************
*** 2539,2545 ****
  		  /* Add "Cc:" regardless of user settings */
  		  perform_cc = -1;
  	       }
! 	  }
       }
  
     /* Some mailing lists have a Mail-Followup-To header.  But do this if there
--- 2674,2713 ----
  		  /* Add "Cc:" regardless of user settings */
  		  perform_cc = -1;
  	       }
! 	  } /* if (cc_address != NULL) */
! 	/* There's a Followup-To to a normal Newsgroup */
! 	if (Slrn_Warn_Followup_To && (newsgroups != NULL))
! 	  {
! 	     int warn = 0;
! 	     if (Slrn_Warn_Followup_To == 1)
! 	       /* Warn if "Followup-To:" does not include current newsgroup */
! 	       { 
! 		  char* lpos;
! 		  char* rpos = newsgroups;
! 		  char* epos = rpos + strlen(rpos);
! 		  warn = 1;
! 		  while (rpos < epos)
! 		    {
! 		       lpos = rpos;
! 		       rpos = slrn_strchr(lpos, ',');
! 		       if (rpos == NULL)
! 			 rpos = epos;
! 		       if ((strlen(Slrn_Current_Group_Name) == rpos-lpos) &&
! 			   (0 == strncmp(lpos, Slrn_Current_Group_Name, rpos-lpos)))
! 			 {
! 			    warn = 0;
! 			    break;
! 			 }
! 		       rpos++;
! 		    }
! 	       }
! 	     else
! 	       warn = 1;
! 	     
! 	     if (warn &&
! 		 (slrn_get_yesno (1, "\"Followup-To\" %s set. Follow", newsgroups) == 0))
! 	       newsgroups = NULL;
! 	  } /* if (Slrn_Warn_Followup_To) */
       }
  
     /* Some mailing lists have a Mail-Followup-To header.  But do this if there
***************
*** 2578,2583 ****
--- 2746,2777 ----
  	  newsgroups = "";
       }
     
+    if ((strchr(newsgroups, ',')) != NULL)
+      {
+ 	rsp = slrn_get_response ("pPfFoOcC","Crossposting. \001Post, \001Followup-To Current NG, post \001Only to Current NG, \001Cancel.");
+ 	
+         switch (rsp)
+           {
+            case 'p':
+            case 'P':
+              break;
+ 
+            case 'f':
+            case 'F':
+ 	     followupto = Slrn_Current_Group_Name;
+ 	     break;
+ 
+            case 'o':
+            case 'O':
+ 	     newsgroups = Slrn_Current_Group_Name;
+ 	     break;
+ 
+            case 'c':
+            case 'C':
+ 	     return;
+ 	  }
+      }
+    
     if (perform_cc == -1)
       {
  	if ((NULL != (cc_address = slrn_extract_header ("X-Mail-Copies-To: ", 18)))
***************
*** 2664,2669 ****
--- 2858,2866 ----
       }
     else subject = "";
     
+    subject = slrn_safe_strmalloc (subject);
+    strip_subject_was (subject);
+       
     if (Slrn_Use_Tmpdir)
       fp = slrn_open_tmpfile (file, "w");
     else fp = slrn_open_home_file (SLRN_FOLLOWUP_FILENAME, "w", file, 0);
***************
*** 2706,2712 ****
  	n++;
       }
     
!    fprintf (fp, "Followup-To: \n");
     n++;
     
     n += slrn_add_custom_headers (fp, Slrn_Followup_Custom_Headers, slrn_insert_followup_format);
--- 2903,2916 ----
  	n++;
       }
     
!    if ((followupto == NULL) || (*followupto == 0))
!      {	   
! 	fprintf (fp, "Followup-To: \n");
!      } 
!    else
!      {
! 	fprintf (fp, "Followup-To: %s\n", followupto);
!      }	   
     n++;
     
     n += slrn_add_custom_headers (fp, Slrn_Followup_Custom_Headers, slrn_insert_followup_format);
***************
*** 2736,2746 ****
  
     while (l != NULL)
       {
  	if (strip_sig
  	    && (l->flags & SIGNATURE_LINE))
  	  break;
  
! 	fprintf (fp, "%s%s\n", quote_str, l->buf);
  	
  	l = l->next;
       }
--- 2940,2952 ----
  
     while (l != NULL)
       {
+ 	int smart_space = Slrn_Smart_Quote && ! (l->flags & QUOTE_LINE) && prefix_arg != 2;
+ 	
  	if (strip_sig
  	    && (l->flags & SIGNATURE_LINE))
  	  break;
  
! 	fprintf (fp, "%s%s%s\n", quote_str, (smart_space)? " " : "" , l->buf);
  	
  	l = l->next;
       }
***************
*** 2767,2772 ****
--- 2973,2979 ----
     if (Slrn_Use_Tmpdir) (void) slrn_delete_file (file);
     
     free_and_return:
+    slrn_free (subject);
  #if SLRN_HAS_SLANG
     if (free_cc_string && (cc_address != NULL))
       SLang_free_slstring (cc_address);
***************
*** 2780,2786 ****
   */
  static void supersede (void) /*{{{*/
  {
!    char *msgid, *newsgroups, *subject, *xref;
     Slrn_Article_Line_Type *l;
     FILE *fp;
     char file[SLRN_MAX_PATH_LEN];
--- 2987,2993 ----
   */
  static void supersede (void) /*{{{*/
  {
!    char *followupto, *msgid, *newsgroups, *subject, *xref;
     Slrn_Article_Line_Type *l;
     FILE *fp;
     char file[SLRN_MAX_PATH_LEN];
***************
*** 2819,2824 ****
--- 3026,3033 ----
   
     if (NULL == (newsgroups = slrn_extract_header ("Newsgroups: ", 12)))
       newsgroups = "";
+    if (NULL == (followupto = slrn_extract_header ("Followup-To: ", 12)))
+      followupto = "";
     if (NULL == (subject = slrn_extract_header ("Subject: ", 9)))
       subject = "";
     if (NULL == (msgid = slrn_extract_header ("Message-ID: ", 12)))
***************
*** 2835,2842 ****
  	return;
       }
  
!     fprintf (fp, "Newsgroups: %s\nSubject: %s\nSupersedes: %s\n",
!  	    newsgroups, subject, msgid);  n = 3;
      
      if (xref != NULL)
        {
--- 3044,3052 ----
  	return;
       }
  
!     fprintf (fp,
!              "Newsgroups: %s\nSubject: %s\nSupersedes: %s\nFollowup-To: %s\n",
!              newsgroups, subject, msgid, followupto);  n = 4;
      
      if (xref != NULL)
        {
***************
*** 2855,2863 ****
  	fprintf (fp, "Reply-To: %s\n", Slrn_User_Info.replyto);
  	n++;
       }
! 
!     fprintf (fp, "Followup-To: \n");
!     n++;
      
      fputs ("\n", fp);
      n += 1;	
--- 3065,3072 ----
  	fprintf (fp, "Reply-To: %s\n", Slrn_User_Info.replyto);
  	n++;
       }
!     
!     n += slrn_add_custom_headers (fp, Slrn_Supersedes_Custom_Headers, slrn_insert_followup_format);
      
      fputs ("\n", fp);
      n += 1;	
***************
*** 3280,3328 ****
  
  static int save_article_as_unix_mail (Slrn_Header_Type *h, FILE *fp) /*{{{*/
  {
     char *from;
     time_t now;
     Slrn_Article_Line_Type *l;
-    int is_wrapped;
- 
-    if (read_article (h, Slrn_Del_Article_Upon_Read, 0) < 0) return -1;
- 
-    is_wrapped = Slrn_Current_Article->is_wrapped;
-    if (is_wrapped) unwrap_article ();
  
!    from = slrn_extract_header ("From: ", 6);
     if (from != NULL) from = parse_from (from);
     if ((from == NULL) || (*from == 0)) from = "nobody@nowhere";
     
     time (&now);
     fprintf (fp, "From %s %s", from, ctime(&now));
     
!    l = Slrn_Current_Article->lines;
!    while (l != NULL)
       {
! 	if ((*l->buf == 'F')
! 	    && !strncmp ("From", l->buf, 4)
! 	    && ((unsigned char)(l->buf[4]) <= ' '))
  	  {
! 	     putc ('>', fp);
  	  }
  	
! 	fputs (l->buf, fp);
! 	putc ('\n', fp);
! 	l = l->next;
       }
!    fputs ("\n\n", fp);
!    
! #if SLRN_HAS_MIME
!    /* read_article was called without MIME processing */
!    if (Slrn_Use_Mime)
       {
! 	slrn_mime_article_init ();
! 	slrn_mime_process_article (Slrn_Current_Article);
       }
! #endif
! 
!    if (is_wrapped) wrap_article ();
  
     return 0;
  }
--- 3489,3593 ----
  
  static int save_article_as_unix_mail (Slrn_Header_Type *h, FILE *fp) /*{{{*/
  {
+    int reload;
     char *from;
     time_t now;
     Slrn_Article_Line_Type *l;
  
!    from = h->from;
     if (from != NULL) from = parse_from (from);
     if ((from == NULL) || (*from == 0)) from = "nobody@nowhere";
     
+    if ((Header_Showing == h)
+ #if SLRN_HAS_MIME
+        && (Slrn_Mime_Was_Modified == 0)
+ #endif
+        && (Slrn_Current_Article != NULL))
+      reload = 0; /* We can use the cached copy */
+    else
+      reload = 1;
+    
+    if (reload)
+      {
+ 	int status = Slrn_Server_Obj->sv_select_article (h->number, h->msgid);
+ 	if (status != OK_ARTICLE)
+ 	  return -1;
+      }
+    else
+      l = Slrn_Current_Article->lines;
+    
     time (&now);
     fprintf (fp, "From %s %s", from, ctime(&now));
     
!    if (reload)
       {
! 	char buf[NNTP_BUFFER_SIZE];
! 	int status, num_lines_update;
! 	int total_lines = 0;
! 	
! 	if ((num_lines_update = Slrn_Reads_Per_Update) < 5)
  	  {
! 	     if (h->lines < 200)
! 	       num_lines_update = 20;
! 	     else 
! 	       num_lines_update = 50;
  	  }
  	
! 	while (1)
! 	  {
! 	     status = Slrn_Server_Obj->sv_read_line(buf, sizeof(buf));
! 	     if (status == 0)
! 	       break;
! 	     if ((status == -1)
! 		 || (SLang_Error == USER_BREAK))
! 	       {
! 		  if (Slrn_Server_Obj->sv_reset != NULL)
! 		    Slrn_Server_Obj->sv_reset ();
! 		  slrn_error ("Article transfer aborted or connection lost");
! 		  break;
! 	       }
! 	     
! 	     total_lines++;
! 	     if ((1 == (total_lines % num_lines_update))
! 		 && (total_lines < (unsigned int) h->lines))
! 	       {
! 		  if (h->tag_number)
! 		    slrn_message_now ("#%2d/%-2d: Saved %4d/%-4d lines (%s)",
! 				      h->tag_number, Num_Tag_List.len,
! 				      total_lines, h->lines, h->subject);
! 		  else
! 		    slrn_message_now ("[%d] Saved %d/%d lines so far...",
! 				      h->number, total_lines, h->lines);
! 	       }
! 	     
! 	     if ((*buf == 'F')
! 		 && !strncmp ("From", buf, 4)
! 		 && ((unsigned char)(buf[4]) <= ' '))
! 	       {
! 		  putc('>', fp);
! 	       }
! 	     
! 	     fputs(buf, fp);
! 	     putc ('\n', fp);
! 	  }
       }
!    else
       {
! 	while (l != NULL)
! 	  {
! 	     if ((*l->buf == 'F')
! 		 && !strncmp ("From", l->buf, 4)
! 		 && ((unsigned char)(l->buf[4]) <= ' '))
! 	       {
! 		  putc ('>', fp);
! 	       }
! 	     
! 	     fputs (l->buf, fp);
! 	     putc ('\n', fp);
! 	     l = l->next;
! 	  }
       }
!    fputs ("\n\n", fp);
  
     return 0;
  }
***************
*** 6336,6342 ****
  
  static void undelete_header (Slrn_Header_Type *h) /*{{{*/
  {
-    if (h->flags & HEADER_TAGGED) return;
     h->flags &= ~HEADER_READ;
  }
  
--- 6601,6606 ----
***************
*** 7750,7755 ****
--- 8014,8038 ----
     char *fmt;
     char ch;
  
+ #if SLRN_HAS_SORT_BY_SCORE
+    int score;
+    int color_by_score;
+    score = ((h->child != NULL) && (h->child->flags & HEADER_HIDDEN)
+            ? h->thread_score : h->score);
+ 
+    if (Slrn_Color_Score || Slrn_Color_Subject){
+      if (score >= Slrn_High_Score_Min) color_by_score = HIGH_SCORE_COLOR;
+      else {
+        if (score){
+ 	 if (score > 0) color_by_score = POS_SCORE_COLOR;
+          else color_by_score = NEG_SCORE_COLOR;
+          }
+        else
+ 	 color_by_score = SUBJECT_COLOR;
+      }
+    }
+ #endif
+    
     SLsmg_gotorc (row, 0);
     slrn_set_color (0);
  
***************
*** 7820,7832 ****
  	   case 'S':
  	     if (Slrn_Display_Score)
  	       {
! 		  int score;
! 		  
! 		  score = ((h->child != NULL) && (h->child->flags & HEADER_HIDDEN)
! 			   ? h->thread_score : h->score);
  		  
  		  s = buf;
! 		  if (score)
  		    sprintf (s, "%d", score);
  		  else *s = 0;
  	       }
--- 8103,8112 ----
  	   case 'S':
  	     if (Slrn_Display_Score)
  	       {
! 		  if (Slrn_Color_Score) color = color_by_score;
  		  
  		  s = buf;
! 		  if (score || Slrn_Display_Zero_Score)
  		    sprintf (s, "%d", score);
  		  else *s = 0;
  	       }
***************
*** 7858,7864 ****
--- 8138,8150 ----
  	     if (s == NULL) s = "";
  	     break;
  	   case 's':
+ #if SLRN_HAS_SORT_BY_SCORE
+              if (Slrn_Color_Subject) color = color_by_score;
+              else
+ #endif
  	     color = SUBJECT_COLOR;
+ 	     if (Slrn_Highlight_Unread && !(h->flags & HEADER_READ))
+ 	       color += 5; /* cf. slrn.h */
  	     s = disp_get_header_subject (h, row);
  	     break;
  #if SLRN_HAS_GROUPLENS
***************
*** 7872,7877 ****
--- 8158,8180 ----
  	     color = DATE_COLOR;
  	     break;
  	     
+ 	   case 'D':
+ 	     if (NULL == (s = h->date))
+ 	       s = "";
+ 	     else
+ 	       {
+ 		  char *fmtstr;
+ 		  
+ 		  fmtstr = Slrn_Overview_Date_Format;
+ 		  if (fmtstr == NULL)
+ 		    fmtstr = "%d %b %y %H:%M";
+ 		  
+ 		  slrn_strftime (buf, sizeof(buf), fmtstr, s);
+ 		  
+ 		  s = buf;
+ 	       }
+ 	     break;
+ 	     	     
  	   case 'n':
  	     s = buf;
  	     sprintf (s, "%d", h->number);
diff -cr slrn-0.9.6.3.orig/src/art.h slrn-0.9.6.3/src/art.h
*** slrn-0.9.6.3.orig/src/art.h	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/art.h	Tue Jan  2 21:10:20 2001
***************
*** 30,35 ****
--- 30,39 ----
  extern char *Slrn_Art_Help_Line;
  extern char *Slrn_Followup_Custom_Headers;
  extern char *Slrn_Reply_Custom_Headers;
+ extern char *Slrn_Supersedes_Custom_Headers;
+ extern char *Slrn_Strip_Was_Regexp;
+ extern char *Slrn_Overview_Date_Format;
+ extern char *Slrn_Followup_Date_Format;
  
  extern int Slrn_Simulate_Graphic_Chars;
  
***************
*** 39,49 ****
--- 43,55 ----
  extern int Slrn_Query_Next_Article;
  extern int Slrn_Query_Next_Group;
  extern int Slrn_Auto_CC_To_Poster;
+ extern int Slrn_Send_To_To;
  extern int Slrn_Score_After_XOver;
  extern int Slrn_Use_Tmpdir;
  extern int Slrn_Sorting_Mode;
  extern int Slrn_Threads_Visible;
  extern int Slrn_Wrap_Mode;
+ extern int Slrn_Wrap_Method;
  extern int Slrn_Use_Header_Numbers;
  extern int Slrn_Reads_Per_Update;
  extern int Slrn_High_Score_Min;
***************
*** 52,57 ****
--- 58,64 ----
  extern int Slrn_Signature_Hidden;
  extern int Slrn_Pgp_Signature_Hidden;
  extern int Slrn_Verbatim_Marks_Hidden;
+ extern int Slrn_Warn_Followup_To;
  
  extern char *Slrn_X_Browser;
  
***************
*** 218,224 ****
--- 225,235 ----
  
  #if SLRN_HAS_SORT_BY_SCORE
  extern int Slrn_Display_Score;
+ extern int Slrn_Color_Score;
+ extern int Slrn_Color_Subject;
+ extern int Slrn_Display_Zero_Score;
  #endif
+ extern int Slrn_Highlight_Unread;
  
  extern int slrn_set_header_format (unsigned int, char *);
  
diff -cr slrn-0.9.6.3.orig/src/artmisc.c slrn-0.9.6.3/src/artmisc.c
*** slrn-0.9.6.3.orig/src/artmisc.c	Mon Sep 18 00:35:28 2000
--- slrn-0.9.6.3/src/artmisc.c	Tue Jan  2 21:08:52 2001
***************
*** 60,65 ****
--- 60,66 ----
  
  int Slrn_Art_Hide_Quote_Level = 0;
  int Slrn_Wrap_Mode = 3;
+ int Slrn_Wrap_Method = 0;
  
  static char *Super_Cite_Regexp = "^[^A-Za-z0-9]*\"\\([-_a-zA-Z/]+\\)\" == .+";
  
***************
*** 535,540 ****
--- 536,543 ----
  
  		  lbuf += 1;	       /* avoid space at beg of line */
  
+                   if (Slrn_Wrap_Method == 0 || Slrn_Wrap_Method == 2) {
+ 
  		  while (buf0 > lbuf)
  		    {
  		       if ((*buf0 == ' ') || (*buf0 == '\t')
***************
*** 549,554 ****
--- 552,559 ----
  
  		  if (buf0 == lbuf)
  		    {
+ 		       if (Slrn_Wrap_Method == 0) {
+ 
  		       /* Could not find a place to break the line.  Ok, so
  			* we will not break this.  Perhaps it is a URL.  
  			* If not, it is a long word and who cares about it.
***************
*** 559,565 ****
--- 564,579 ----
  
  		       if (ch == 0)
  			 continue;
+ 
+ 		       }
+ 		       else {
+ 		         lbuf = (unsigned char *) l->buf;
+ 			 lbuf += 1; /* avoid space at beg of line */
+ 		       }
+ 
  		    }
+ 
+ 		  }
  		       
  		  /* Start wrapped lines with a space.  To do this, I will
  		   * _temporally_ modify the previous character for the purpose
***************
*** 867,880 ****
  	v = Visible_Headers;
  	while (v != NULL)
  	  {
! 	     char chv = (0x20 | v->header[0]);
  	     
  	     if ((chv == ch)
! 		 && (0 == slrn_case_strncmp ((unsigned char *)l->buf, 
! 					     (unsigned char *)v->header, 
! 					     v->len)))
  	       {
! 		  hide_header = 0;
  		  break;
  	       }
  	     
--- 881,895 ----
  	v = Visible_Headers;
  	while (v != NULL)
  	  {
! 	     int hide = (v->header[0] == '!') ? 1 : 0;
! 	     char chv = (0x20 | v->header[hide]);
  	     
  	     if ((chv == ch)
! 		 && (0 == slrn_case_strncmp ((unsigned char *)l->buf,
! 					     (unsigned char *)v->header + hide,
! 					     (v->len) - hide)))
  	       {
! 		  hide_header = hide;
  		  break;
  	       }
  	     
diff -cr slrn-0.9.6.3.orig/src/config.hin slrn-0.9.6.3/src/config.hin
*** slrn-0.9.6.3.orig/src/config.hin	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/config.hin	Tue Jan  2 20:59:49 2001
***************
*** 38,43 ****
--- 38,49 ----
  /* define if you have memcpy */
  #undef HAVE_MEMCPY
  
+ /* define if you have sys/time.h */
+ #undef HAVE_SYS_TIME_H
+ 
+ /* define if you have gettimeofday */
+ #undef HAVE_GETTIMEOFDAY
+ 
  #undef HAVE_SYS_UTSNAME_H
  #undef HAVE_UNAME
  
diff -cr slrn-0.9.6.3.orig/src/editscore.c slrn-0.9.6.3/src/editscore.c
*** slrn-0.9.6.3.orig/src/editscore.c	Mon Sep 18 00:35:31 2000
--- slrn-0.9.6.3/src/editscore.c	Tue Jan  2 21:01:24 2001
***************
*** 48,53 ****
--- 48,54 ----
     char file[256];
     char qregexp[512];
     unsigned int mm = 0, dd = 0, yy = 0;
+    int days = 0;
     int use_expired = 0;
     unsigned int linenum = 0;
     char *q, *ng = newsgroup;
***************
*** 80,94 ****
  	while (1)
  	  {
  	     *qregexp = 0;
! 	     if (-1 == slrn_read_input ("Expires (MM/DD/YYYY or DD-MM-YYYY or leave blank)", NULL, qregexp, 1, 0))
  	       return -1;
  	     if (*qregexp)
  	       {
! 		  if (((3 != sscanf (qregexp, "%u/%u/%u", &mm, &dd, &yy))
! 		       && (3 != sscanf (qregexp, "%u-%u-%u", &dd, &mm, &yy)))
! 		      || (dd > 31)
! 		      || (mm > 12)
! 		      || (yy < 1900))
  		    continue;
  		  use_expired = 1;
  		  break;
--- 81,109 ----
  	while (1)
  	  {
  	     *qregexp = 0;
! 	     if (-1 == slrn_read_input ("Expires (MM/DD/YYYY, DD-MM-YYYY, +NN (days) or leave blank)", NULL, qregexp, 1, 0))
  	       return -1;
  	     if (*qregexp)
  	       {
! 		  if (1 == sscanf(qregexp, "+%d",&days)) {
! 		     if (days < 1) {
! 		       continue;
! 		     } else {
! 			time_t now;
! 			struct tm *newtime;
! 			time(&now);
! 			now += days * 24 * 3600;
! 			newtime = localtime(&now);
! 			dd = newtime->tm_mday;
! 			mm = newtime->tm_mon + 1;
! 			yy = newtime->tm_year + 1900;
! 		     }
! 		  }
! 		  else if (((3 != sscanf (qregexp, "%u/%u/%u", &mm, &dd, &yy))
! 			    && (3 != sscanf (qregexp, "%u-%u-%u", &dd, &mm, &yy)))
! 			    || (dd > 31)
! 			    || (mm > 12)
! 			    || (yy < 1900))
  		    continue;
  		  use_expired = 1;
  		  break;
***************
*** 117,123 ****
  	  }
  	
  	myclock = time((time_t *) 0);
! 	fprintf (fp, "\n%%Score created by slrn on %s\n[%s]\nScore: %d\n",
  		 (char *) ctime(&myclock), ng, score);
  	
  	if (use_expired)
--- 132,138 ----
  	  }
  	
  	myclock = time((time_t *) 0);
! 	fprintf(fp, "\n%%BOS\n%%Score created by slrn on %s\n[%s]\nScore: %d\n",
  		 (char *) ctime(&myclock), ng, score);
  	
  	if (use_expired)
***************
*** 151,156 ****
--- 166,172 ----
  	if (q == NULL) q = newsgroup;
  	fprintf (fp, "%%\tNewsgroup: %s\n", q);
  	
+ 	fprintf (fp, "%%EOS\n");
  	file_modified = 1;
       }
     
diff -cr slrn-0.9.6.3.orig/src/group.c slrn-0.9.6.3/src/group.c
*** slrn-0.9.6.3.orig/src/group.c	Mon Sep 18 00:35:27 2000
--- slrn-0.9.6.3/src/group.c	Tue Jan  2 20:59:15 2001
***************
*** 116,121 ****
--- 116,122 ----
  static void group_update_screen (void);
  static void group_quick_help (void);
  static void save_newsrc_cmd (void);
+ static void read_and_parse_active (int);
  
  /*}}}*/
  
***************
*** 271,302 ****
  
  /*}}}*/
  
! static int group_sync_group_with_server (Slrn_Group_Type *g, int *minp, int *maxp) /*{{{*/
  {
!    int min, max, n, max_available;
!    char *group;
     Slrn_Range_Type *r;
-    int status;
-    
-    if (g == NULL) return -1;
-    
-    group = g->group_name;
-    
-    slrn_message_now ("Selecting %s ...", group);
-    
-    status = Slrn_Server_Obj->sv_select_group (group, minp, maxp);
-    if (status == -1)
-      return -1;
-    
-    if (status != OK_GROUP)
-      {
- 	g->flags |= GROUP_UNSUBSCRIBED;
- 	slrn_error ("This group appears to be bogus.");
- 	return -1;
-      }
- 
-    min = *minp;
-    max = *maxp;
     
     if (max == 0)
       {
--- 272,281 ----
  
  /*}}}*/
  
! static int group_update_range (Slrn_Group_Type *g, int min, int max) /*{{{*/
  {
!    int n, max_available;
     Slrn_Range_Type *r;
     
     if (max == 0)
       {
***************
*** 360,370 ****
--- 339,384 ----
  	  r->next->min = 1;
  #endif
       }
+    else
+      g->unread = max_available;
+ 
+    if ((g->flags & GROUP_UNSUBSCRIBED) == 0) 
+      {
+ 	if (g->unread > 0)
+ 	  g->flags &= ~GROUP_HIDDEN;
+ 	else if (Groups_Hidden && (g != Slrn_Group_Current_Group))
+ 	  g->flags |= GROUP_HIDDEN;
+      }
     
     return 0;
  }
  
+ /*}}}*/
  
+ static int group_sync_group_with_server (Slrn_Group_Type *g, int *minp, int *maxp) /*{{{*/
+ {
+    char *group;
+    int status;
+    
+    if (g == NULL) return -1;
+    
+    group = g->group_name;
+    
+    slrn_message_now ("Selecting %s ...", group);
+    
+    status = Slrn_Server_Obj->sv_select_group (group, minp, maxp);
+    if (status == -1)
+      return -1;
+    
+    if (status != OK_GROUP)
+      {
+ 	g->flags |= GROUP_UNSUBSCRIBED;
+ 	slrn_error ("Group %s appears to be bogus.", group);
+ 	return -1;
+      }
+    
+    return group_update_range (g, *minp, *maxp);
+ }
  
  /*}}}*/
  
***************
*** 536,542 ****
  
  	     if (NULL != (tmp_name = slrn_strnmalloc (name, len, 1)))
  	       {
! 		  fprintf (stderr, "Group %s is bogus,  Ignoring it.\r\n", tmp_name);
  		  slrn_free (tmp_name);
  	       }
  	     return -1;
--- 550,556 ----
  
  	     if (NULL != (tmp_name = slrn_strnmalloc (name, len, 1)))
  	       {
! 		  slrn_error ("Group %s is bogus - ignoring it.", tmp_name);
  		  slrn_free (tmp_name);
  	       }
  	     return -1;
***************
*** 600,605 ****
--- 614,690 ----
  
  /*}}}*/
  
+ /* Rearrange Slrn_Group_Current_Group such that it follows last_group and 
+  * return Slrn_Group_Current_Group.  If last_group is NULL, Slrn_Group_Current_Group
+  * should be put at top of list.
+  */
+ static Slrn_Group_Type *place_group_in_newsrc_order (Slrn_Group_Type *last_group) /*{{{*/
+ {
+    Slrn_Group_Type *next_group, *prev_group;
+    
+    next_group = Slrn_Group_Current_Group->next;
+    prev_group = Slrn_Group_Current_Group->prev;
+    if (next_group != NULL) next_group->prev = prev_group;
+    if (prev_group != NULL) prev_group->next = next_group;
+    
+    Slrn_Group_Current_Group->prev = last_group;
+    if (last_group != NULL)
+      {
+ 	Slrn_Group_Current_Group->next = last_group->next;
+ 	
+ 	if (Slrn_Group_Current_Group->next != NULL)
+ 	  Slrn_Group_Current_Group->next->prev = Slrn_Group_Current_Group;
+ 	
+ 	last_group->next = Slrn_Group_Current_Group;
+      }
+    else if (Slrn_Group_Current_Group != Groups)
+      {
+ 	Slrn_Group_Current_Group->next = Groups;
+ 	if (Groups != NULL) Groups->prev = Slrn_Group_Current_Group;
+ 	Groups = Slrn_Group_Current_Group;
+      }
+    else				       
+      {
+ 	/* correct next_group->prev since it was not set correctly above */
+ 	if (next_group != NULL)
+ 	  next_group->prev = Slrn_Group_Current_Group;
+      }
+ 
+    return Slrn_Group_Current_Group;
+ }
+ 
+ /*}}}*/
+ static Slrn_Group_Type *insert_new_groups () /*{{{*/
+ {
+    Slrn_Group_Type *last_group = NULL;
+    
+    if (Unsubscribed_Groups != NULL)
+      {
+ 	unsigned int subscribe_flag;
+ 	Unsubscribed_Slrn_Group_Type *ug = Unsubscribed_Groups, *ugnext;
+ 	     
+ 	if (Slrn_Unsubscribe_New_Groups)
+ 	  subscribe_flag = GROUP_UNSUBSCRIBED | GROUP_NEW_GROUP_FLAG;
+ 	else subscribe_flag = GROUP_NEW_GROUP_FLAG;
+ 	     
+ 	while (ug != NULL)
+ 	  {
+ 	     ugnext = ug->next;
+ 	     
+ 	     if (-1 != add_group (ug->group_name, strlen (ug->group_name), subscribe_flag, 0))
+ 	       last_group = place_group_in_newsrc_order (last_group);
+ 	     
+ 	     free_unsubscribed_group_type (ug);
+ 	     ug = ugnext;
+ 	  }
+ 	Unsubscribed_Groups = NULL;
+      }
+    
+    return last_group;
+ }
+ 
+ /*}}}*/
+ 
  static void find_line_num (void) /*{{{*/
  {
     Group_Window.lines = (SLscroll_Type *) Groups;
***************
*** 625,650 ****
  }
  
  /*}}}*/
- static void free_all_groups (void) /*{{{*/
- {
-    Slrn_Group_Type *g = Groups;
-    Slrn_Group_Type *nextg;
-    int i;
-    
-    while (g != NULL)
-      {
- 	nextg = g->next;
- 	free_newsgroup_type (g);
- 	g = nextg;
-      }
-    Groups = NULL;
-    Slrn_Group_Current_Group = NULL;
-    SLMEMSET((char *) &Group_Window, 0, sizeof (SLscroll_Window_Type));
-    
-    for (i = 0; i < GROUP_HASH_TABLE_SIZE; i++) Group_Hash_Table[i] = NULL;
- }
- 
- /*}}}*/
  
  static int find_group (char *name) /*{{{*/
  {
--- 710,715 ----
***************
*** 971,1002 ****
  
  static void refresh_groups_cmd (void) /*{{{*/
  {
!    char *group_name;
!    
!    group_name = NULL;
!    if (Slrn_Group_Current_Group != NULL)
!      group_name = slrn_safe_strmalloc (Slrn_Group_Current_Group->group_name);
!    
!    /* slrn_set_suspension (1); */
!    save_newsrc_cmd ();
!    free_all_groups ();
!    /*
!     * Groups_Hidden gets toggled in slrn_read_newsrc, which gets called
!     * in slrn_get_new_news.  Therefore, pre-toggle Groups_Hidden ahead of
!     * time.
!     */
!    Groups_Hidden = !Groups_Hidden;
!    if (-1 == slrn_get_new_news (1, 0))
       {
! 	slrn_quit (0);
       }
!    if (group_name != NULL)
       {
! 	(void) find_group (group_name);
! 	slrn_free (group_name);
       }
-    /* slrn_set_suspension (0); */
  
     init_group_win_struct ();
     group_quick_help ();
  }
--- 1036,1064 ----
  
  static void refresh_groups_cmd (void) /*{{{*/
  {
!    if (Slrn_List_Active_File)
!      read_and_parse_active(0);
! 
!    if (Slrn_Check_New_Groups)
       {
! 	slrn_check_new_groups (0);
! 	insert_new_groups ();
       }
!    
!    if (!Slrn_List_Active_File)
       {
! 	Slrn_Group_Type *g = Groups;
! 	int min, max;
! 	
! 	while (g != NULL)
! 	  {
! 	     group_sync_group_with_server(g, &min, &max);
! 	     g = g->next;
! 	  }
       }
  
+    slrn_read_group_descriptions ();
+    
     init_group_win_struct ();
     group_quick_help ();
  }
***************
*** 2003,2008 ****
--- 2065,2072 ----
  	fgets (line, sizeof (line), fp);
  	slrn_fclose (fp);
  	
+ 	slrn_message_now ("Checking for new groups ...");
+ 	
  	time (&tloc);
  	parse_error = 1;
  	
***************
*** 2134,2180 ****
  
  /*}}}*/
  
- /* Rearrange Slrn_Group_Current_Group such that it follows last_group and 
-  * return Slrn_Group_Current_Group.  If last_group is NULL, Slrn_Group_Current_Group
-  * should be put at top of list.
-  */
- static Slrn_Group_Type *place_group_in_newsrc_order (Slrn_Group_Type *last_group) /*{{{*/
- {
-    Slrn_Group_Type *next_group, *prev_group;
-    
-    next_group = Slrn_Group_Current_Group->next;
-    prev_group = Slrn_Group_Current_Group->prev;
-    if (next_group != NULL) next_group->prev = prev_group;
-    if (prev_group != NULL) prev_group->next = next_group;
-    
-    Slrn_Group_Current_Group->prev = last_group;
-    if (last_group != NULL)
-      {
- 	Slrn_Group_Current_Group->next = last_group->next;
- 	
- 	if (Slrn_Group_Current_Group->next != NULL)
- 	  Slrn_Group_Current_Group->next->prev = Slrn_Group_Current_Group;
- 	
- 	last_group->next = Slrn_Group_Current_Group;
-      }
-    else if (Slrn_Group_Current_Group != Groups)
-      {
- 	Slrn_Group_Current_Group->next = Groups;
- 	if (Groups != NULL) Groups->prev = Slrn_Group_Current_Group;
- 	Groups = Slrn_Group_Current_Group;
-      }
-    else				       
-      {
- 	/* correct next_group->prev since it was not set correctly above */
- 	if (next_group != NULL)
- 	  next_group->prev = Slrn_Group_Current_Group;
-      }
- 
-    return Slrn_Group_Current_Group;
- }
- 
- /*}}}*/
- 
  static int parse_active_line (char *name, unsigned int *lenp, /*{{{*/
  			      int *minp, int *maxp)
  {
--- 2198,2203 ----
***************
*** 2194,2229 ****
  
  /*}}}*/
  
! static int read_and_parse_newsrc_file (void)
  {
!    Slrn_Group_Type *last_group = NULL;
!    VFILE *vp;
!    char *vline;
!    unsigned int vlen;
!    char file[SLRN_MAX_PATH_LEN];
  
!    if (Unsubscribed_Groups != NULL)
       {
! 	unsigned int subscribe_flag;
! 	Unsubscribed_Slrn_Group_Type *ug = Unsubscribed_Groups, *ugnext;
! 	     
! 	if (Slrn_Unsubscribe_New_Groups)
! 	  subscribe_flag = GROUP_UNSUBSCRIBED | GROUP_NEW_GROUP_FLAG;
! 	else subscribe_flag = GROUP_NEW_GROUP_FLAG;
! 	     
! 	while (ug != NULL)
  	  {
! 	     ugnext = ug->next;
! 	     
! 	     if ((-1 != add_group (ug->group_name, strlen (ug->group_name), subscribe_flag, 0))
! 		 && Slrn_List_Active_File)
! 	       last_group = place_group_in_newsrc_order (last_group);
  	     
! 	     free_unsubscribed_group_type (ug);
! 	     ug = ugnext;
  	  }
- 	Unsubscribed_Groups = NULL;
       }
  
     if ((NULL == (vp = slrn_open_home_vfile (Slrn_Newsrc_File, file)))
         && (NULL == (vp = slrn_open_home_vfile (".newsrc", file))))
--- 2217,2300 ----
  
  /*}}}*/
  
! static void read_and_parse_active (int create_flag) /*{{{*/
  {
!    char line[NNTP_BUFFER_SIZE];
!    int count = 0;
!    int initial_run = (Groups == NULL);
  
!    if (OK_GROUPS != Slrn_Server_Obj->sv_list_active ())
!      slrn_exit_error ("Server failed LIST ACTIVE.");
! 
!    while (1)
       {
! 	unsigned int len;
! 	int min, max;
! 	int status;
! 
! 	status = Slrn_Server_Obj->sv_read_line (line, sizeof(line));
! 	if (status == -1)
  	  {
! 	     Slrn_Groups_Dirty = 0;
! 	     slrn_exit_error ("Read from server failed");
! 	  }
! 	if (status == 0)
! 	  break;
! 
! 	parse_active_line (line, &len, &min, &max);
! 	
! 	if (!initial_run)
! 	  {
! 	     Slrn_Group_Type *g = find_group_entry (line, len);
! 	     if (g != NULL)
! 	       {
! 		  group_update_range (g, min, max);
! 		  continue;
! 	       }
! 	  }
! 	
! 	if (NULL == create_group_entry (line, len, min, max, 0, 0))
! 	  continue;
! 	
! 	if (create_flag)
! 	  {
! 	     count++;
! 	     count = count % 50;
! 	     if (count == 0)
! 	       {
! 		  putc ('.', stdout);
! 		  fflush (stdout);
! 	       }
  	     
! 	     if ((*line == 'n')
! 		 && (!strncmp (line,    "news.newusers.questions", 23)
! 		     || !strncmp (line, "news.groups.questions", 21)
! 		     || !strncmp (line, "news.answers", 12)
! 		     || !strncmp (line, "news.announce.newusers", 22)
! 		     || !strncmp (line, "news.software.readers", 21)))
! 	       {
! 		  add_group (line, len, 0, 1);
! 	       }
! 	     else if ((*line == 'a')
! 		      && (!strncmp (line, "alt.test", 8))
! 		      && (line[8] <= ' '))
! 	       {
! 		  add_group (line, len, 0, 1);
! 	       }
! 	     else add_group (line, len, GROUP_UNSUBSCRIBED, 1);
  	  }
       }
+ }
+ 
+ /*}}}*/
+ 
+ static int read_and_parse_newsrc_file (void)
+ {
+    VFILE *vp;
+    char *vline;
+    unsigned int vlen;
+    char file[SLRN_MAX_PATH_LEN];
+    Slrn_Group_Type *last_group = insert_new_groups ();
  
     if ((NULL == (vp = slrn_open_home_vfile (Slrn_Newsrc_File, file)))
         && (NULL == (vp = slrn_open_home_vfile (".newsrc", file))))
***************
*** 2257,2267 ****
     vclose (vp);
     return 0;
  }
- 
     
  int slrn_read_newsrc (int create_flag) /*{{{*/
  {
!    char line[NNTP_BUFFER_SIZE];
     
     if (create_flag)
       {
--- 2328,2344 ----
     vclose (vp);
     return 0;
  }
     
  int slrn_read_newsrc (int create_flag) /*{{{*/
  {
!    char *msg1 = "Checking news via active file ...";
!    char *msg2 = "Checking news ...";
!    char *msg;
!    
!    if (Slrn_List_Active_File) msg = msg1;
!    else msg = msg2;
!    
!    slrn_message_now (msg);
     
     if (create_flag)
       {
***************
*** 2281,2340 ****
     
     if (create_flag || Slrn_List_Active_File)
       {
! 	int count = 0;
! 
! 	if (OK_GROUPS != Slrn_Server_Obj->sv_list_active ())
! 	  slrn_exit_error ("Server failed LIST ACTIVE.");
! 
! 	while (1)
! 	  {
! 	     unsigned int len;
! 	     int min, max;
! 	     int status;
! 
! 	     status = Slrn_Server_Obj->sv_read_line (line, sizeof(line));
! 	     if (status == -1)
! 	       {
! 		  Slrn_Groups_Dirty = 0;
! 		  slrn_exit_error ("Read from server failed");
! 	       }
! 	     if (status == 0)
! 	       break;
! 
! 	     parse_active_line (line, &len, &min, &max);
! 	     
! 	     if (NULL == create_group_entry (line, len, min, max, 0, 0))
! 	       continue;
! 	     
! 	     
! 	     if (create_flag)
! 	       {
! 		  count++;
! 		  count = count % 50;
! 		  if (count == 0)
! 		    {
! 		       putc ('.', stdout);
! 		       fflush (stdout);
! 		    }
! 		  
! 		  if ((*line == 'n')
! 		      && (!strncmp (line,    "news.newusers.questions", 23)
! 			  || !strncmp (line, "news.groups.questions", 21)
! 			  || !strncmp (line, "news.answers", 12)
! 			  || !strncmp (line, "news.announce.newusers", 22)
! 			  || !strncmp (line, "news.software.readers", 21)))
! 		    {
! 		       add_group (line, len, 0, 1);
! 		    }
! 		  else if ((*line == 'a')
! 			   && (!strncmp (line, "alt.test", 8))
! 			   && (line[8] <= ' '))
! 		    {
! 		       add_group (line, len, 0, 1);
! 		    }
! 		  else add_group (line, len, GROUP_UNSUBSCRIBED, 1);
! 	       }
! 	  }
       }
     
     if ((create_flag == 0)
--- 2358,2364 ----
     
     if (create_flag || Slrn_List_Active_File)
       {
! 	read_and_parse_active (create_flag);
       }
     
     if ((create_flag == 0)
diff -cr slrn-0.9.6.3.orig/src/interp.c slrn-0.9.6.3/src/interp.c
*** slrn-0.9.6.3.orig/src/interp.c	Mon Sep 18 00:35:30 2000
--- slrn-0.9.6.3/src/interp.c	Tue Jan  2 21:09:19 2001
***************
*** 1054,1059 ****
--- 1054,1060 ----
     MAKE_INTRINSIC_0("collapse_thread", collapse_thread, SLANG_VOID_TYPE),
     MAKE_INTRINSIC_0("collapse_threads", collapse_threads, SLANG_VOID_TYPE),
     MAKE_INTRINSIC_0("current_newsgroup", current_group_name, SLANG_STRING_TYPE),
+    MAKE_INTRINSIC_S("datestring_to_unixtime", slrn_date_to_order_parm, SLANG_INT_TYPE),
     MAKE_INTRINSIC_SSS("definekey", definekey, SLANG_VOID_TYPE),
     MAKE_INTRINSIC_S("extract_article_header", extract_article_header, SLANG_STRING_TYPE),
     MAKE_INTRINSIC_S("extract_displayed_article_header", extract_current_article_header, SLANG_STRING_TYPE),
diff -cr slrn-0.9.6.3.orig/src/mime.c slrn-0.9.6.3/src/mime.c
*** slrn-0.9.6.3.orig/src/mime.c	Mon Sep 18 00:35:27 2000
--- slrn-0.9.6.3/src/mime.c	Tue Jan  2 21:08:34 2001
***************
*** 66,71 ****
--- 66,72 ----
     "ISO-8859-",
     "iso-latin1",		       /* knews adds his one */
     "KOI8-R",
+    "utf-8",			 /* we now have a function to decode this */
     NULL
  };
  
***************
*** 345,350 ****
--- 346,419 ----
     return dest;
  }
  
+ static char *utf_to_unicode (int *out, char *in, char *srcmax)
+ {
+    int mask = 0;
+    short len = 0, i;
+    
+    for (i = 1; i < 8; i++)
+      {
+ 	if ((*in & (mask |(0x01 << 8-i))) == mask)
+ 	  {
+ 	     len = i;
+ 	     break;
+ 	  }
+ 	mask = (mask |(0x01 << 8-i));
+      }
+    
+    if ((len == 0) || (len == 2) || (in + len - 1 > srcmax))
+      {
+ 	*out = -1;
+ 	return in + 1;
+      }   
+    if (len > 1) len--;
+    
+    for (i = 1; i < len; i++)
+      if ((in[i] & 0xC0) != 0x80)
+        {
+ 	  *out = -1;
+ 	  return in + 1;
+        }
+    
+    *out = ((int) in[0]) & ~mask & 0xFF;
+    for (i = 1; i < len; i++)
+      *out = (*out << 6) | (((int) in[i]) & 0x7F);
+    
+    if (!*out)
+      *out = -1;
+    
+    return in + len;
+ }
+ 
+ static char *decode_utf8 (char *dest, char *src, char *srcmax, char *utf8_error)
+ {
+    int ch;
+    if (utf8_error != NULL)
+      *utf8_error = 0;
+    
+    while (src < srcmax)
+      {
+ 	if (*src & 0x80)
+ 	  {
+ 	     src = utf_to_unicode (&ch, src, srcmax);
+ 	     if (ch < 0)
+ 	       {
+ 		  if (utf8_error != NULL)
+ 		    *utf8_error = 1;
+ 		  *dest++ = '?';
+ 	       }
+ 	     else if (ch < 256)
+ 	       *dest++ = (char) ch;
+ 	     else
+ 	       *dest++ = '?';
+ 	  }
+ 	else
+ 	  *dest++ = *src++;
+      }
+    
+    return dest;
+ }
+ 
  int slrn_rfc1522_decode_string (char *s)
  {
     char *s1, *s2, ch;
***************
*** 358,363 ****
--- 427,448 ----
     after_whitespace = NULL;
     after_last_encoded_word = NULL;
  
+ /* According to current usefor drafts, header lines are always in UTF-8.
+  * Even if some user agents still send raw 8bit, it is safe to call
+  * decode_utf8() -- if it finds 8bit chars that are not valid UTF-8, it
+  * will set ch to 1 and we can leave the line untouched. */
+ #if 1
+    len = strlen (s);
+    s1 = slrn_safe_malloc(len + 1);
+    
+    s2 = decode_utf8 (s1, s, s + len, &ch);
+    *s2 = 0;
+    
+    if (ch == 0)
+      strcpy(s, s1);
+    slrn_free (s1);
+ #endif
+    
     while (1)
       {
  	while ((NULL != (s = slrn_strchr (s, '=')))
***************
*** 421,430 ****
--- 506,521 ----
  	/* Note: these functions return a pointer to the END of the decoded
  	 * text.
  	 */
+ 	s2 = s1;
+ 	
  	if (method == 'B')
  	  s1 = decode_base64 (s1, txt, s);
  	else s1 = decode_quoted_printable (s1, txt, s, 1);
  	
+ 	if (slrn_case_strncmp((unsigned char *)"utf-8",
+ 			      (unsigned char *)charset, 5) == 0)
+ 	  s1 = decode_utf8 (s2, s2, s1, NULL);
+ 	
  	/* Now move everything over */
  	s2 = s + 2;		       /* skip final ?= */
  	s = s1;			       /* start from here next loop */
***************
*** 465,473 ****
  }
  
  
! static void decode_mime_base64 (void)
  {
!    Slrn_Mime_Needs_Metamail = 1;
  }
  
  /* This function checks if the last character on curr_line is an = and 
--- 556,657 ----
  }
  
  
! static void decode_mime_base64 (Slrn_Article_Type *a)
  {
! 	Slrn_Article_Line_Type *l;
! 	Slrn_Article_Line_Type *dest, *body_start, *next;
! 	char *buf_src, *buf_dest; int buf_pos;
! 	char *cp;
! 	char *base;
! 	int len;
! 
! 	if (a == NULL)
! 		return;
! 
! 	l = a->lines;
! 
! 	/* skip header and separator */
! 	while ((l != NULL) && (l->flags & HEADER_LINE) || l->buf[0] == '\0' )
! 		l = l->next;
! 
! 	if (l == NULL) 
! 		return;
! 
! 	body_start = l;
! 
! 	/* let's calculate how much space we need... */
! 	len = 0;
! 	while ( l )
! 	{
! 		len += strlen(l->buf);
! 		l = l->next;
! 	}
! 
! 	/* get some memory */
! 	buf_src = slrn_safe_malloc( sizeof(char) * len + 1 );
! 	buf_dest = slrn_safe_malloc( sizeof(char) * len + 1 );
! 
! 	/* collect all base64 encoded lines into buf_src */
! 	l = body_start;
! 	buf_pos = 0;
! 	while ( l )
! 	{
! 		strcat(buf_src + buf_pos, l->buf);
! 		buf_pos += strlen(l->buf);
! 		l = l->next;
! 	}
! 
! 	/* put decoded article into buf_dest */
! 	cp = decode_base64(buf_dest, buf_src, buf_src+len);
! 	*cp = '\0';
! 
! 	body_start = body_start->prev;
! 	l = body_start->next;
! 
! 	/* free old body */
! 	while ( l )
! 	{
! 		slrn_free(l->buf);
! 		next = l->next;
! 		slrn_free((char *)l);
! 		l = next;
! 	}
! 	body_start->next = NULL;
! 
! 	l = body_start;
! 
! 	base = buf_dest;
! 	cp = buf_dest;
! 
! 	/* put decoded article back into article structure */
! 	while ( (cp=strchr(buf_dest, '\n')) != NULL )
! 	{
! 		len = cp - buf_dest;
! 
! 		l->next = (Slrn_Article_Line_Type *)
! 			slrn_malloc(sizeof(Slrn_Article_Line_Type), 1, 1);
! 
! 		l->next->prev = l;
! 		l = l->next;
! 		l->buf = slrn_malloc(sizeof(char) * len + 1, 0, 1);
! 
! 		strncpy(l->buf, buf_dest, len);
! 		/* terminate string and strip '\r' if necessary */
! 		if ( l->buf[len-1] == '\r' )
! 			l->buf[len-1] = '\0';
! 		else
! 			l->buf[len] = '\0';
! 
! 		buf_dest = cp + 1;
! 
! 		l->next = NULL;
! 	}
! 
! 	slrn_free(buf_src);
! 	slrn_free(base);
! 
! 	a->is_modified = 1;
! 	Slrn_Mime_Was_Modified = 1;
  }
  
  /* This function checks if the last character on curr_line is an = and 
***************
*** 563,568 ****
--- 747,787 ----
       }
  }
  
+ static void decode_mime_utf8 (Slrn_Article_Type *a)
+ {
+    Slrn_Article_Line_Type *line;
+    
+    if (a == NULL)
+      return;
+    
+    line = a->lines;
+ 
+    /* skip to body */
+    while ((line != NULL) && (line->flags & HEADER_LINE))
+      line = line->next;
+    if (line == NULL) return;
+    
+    while (line != NULL)
+      {
+ 	char *b;
+ 	unsigned int len;
+ 	
+ 	b = line->buf;
+ 	len = strlen (b);
+ 	
+ 	b = decode_utf8 (b, b, b + len, NULL);
+ 	
+ 	if (b < line->buf + len)
+ 	  {
+ 	     *b = 0;
+ 	     a->is_modified = 1;
+ 	     Slrn_Mime_Was_Modified = 1;
+ 	  }
+ 	
+ 	line = line->next;
+      }
+ }
+ 
  
  
  void slrn_mime_article_init (void)
***************
*** 597,606 ****
        case ENCODED_8BIT:
        case ENCODED_BINARY:
  	/* Already done. */
! 	return;
  	
        case ENCODED_BASE64:
! 	decode_mime_base64 ();
  	break;
  	
        case ENCODED_QUOTED:
--- 816,825 ----
        case ENCODED_8BIT:
        case ENCODED_BINARY:
  	/* Already done. */
! 	break;
  	
        case ENCODED_BASE64:
! 	decode_mime_base64 (a);
  	break;
  	
        case ENCODED_QUOTED:
***************
*** 611,616 ****
--- 830,840 ----
  	Slrn_Mime_Needs_Metamail = 1;
  	return;
       }
+    
+    if ((Slrn_Mime_Needs_Metamail == 0) &&
+        (slrn_case_strncmp((unsigned char *)"utf-8",
+ 			  (unsigned char *)Char_Set, 5) == 0))
+      decode_mime_utf8 (a);
  }
  
  #ifndef MAXPATHLEN
diff -cr slrn-0.9.6.3.orig/src/misc.c slrn-0.9.6.3/src/misc.c
*** slrn-0.9.6.3.orig/src/misc.c	Mon Sep 18 00:35:27 2000
--- slrn-0.9.6.3/src/misc.c	Tue Jan  2 21:06:11 2001
***************
*** 114,119 ****
--- 114,120 ----
  int Slrn_User_Wants_Confirmation = 1;
  int Slrn_Message_Present = 0;
  int Slrn_Abort_Unmodified = 0;
+ int Slrn_Clock_In_Top_Status_Line = 0;
  
  #ifndef VMS
  char *Slrn_SendMail_Command;
***************
*** 211,223 ****
  
  void slrn_update_top_status_line (void) /*{{{*/
  {
     if (Slrn_Full_Screen_Update == 0) return;
     SLsmg_gotorc (0, 0);
     slrn_set_color (MENU_COLOR);
!    SLsmg_printf ("\
! slrn %s ** Press '?' for help, 'q' to quit. ** Server: %s",
! 		 Slrn_Version,
  		 Slrn_Server_Obj->sv_name);
     SLsmg_erase_eol ();
     slrn_set_color (0);
  }
--- 212,236 ----
  
  void slrn_update_top_status_line (void) /*{{{*/
  {
+    time_t secs;
+    struct tm *now;
+    
     if (Slrn_Full_Screen_Update == 0) return;
     SLsmg_gotorc (0, 0);
     slrn_set_color (MENU_COLOR);
!    if (Slrn_Clock_In_Top_Status_Line)
!      {
! 	secs = time (NULL);
! 	now = localtime (&secs);
!         SLsmg_printf ("slrn %s ** Time: %2d:%02d:%02d ** Server: %s",
! 		 Slrn_Version,  now->tm_hour, now->tm_min, now->tm_sec,
  		 Slrn_Server_Obj->sv_name);
+      }
+    else
+ 	SLsmg_printf ("\
+ slrn %s ** Press '?' for help, 'q' to quit. ** Server: %s",
+ 		Slrn_Version,
+ 		Slrn_Server_Obj->sv_name);
     SLsmg_erase_eol ();
     slrn_set_color (0);
  }
***************
*** 1740,1745 ****
--- 1753,1759 ----
     Slrn_User_Info.reply_string = slrn_safe_strmalloc ("In %n, you wrote:");
  
     Slrn_Courtesy_CC_Message = slrn_safe_strmalloc ("[This message has also been posted.]");
+    Slrn_Strip_Was_Regexp = slrn_safe_strmalloc("(was:.*) *$");
     
     /* Now get default values for rest. */
     host = get_hostname ();
diff -cr slrn-0.9.6.3.orig/src/misc.h slrn-0.9.6.3/src/misc.h
*** slrn-0.9.6.3.orig/src/misc.h	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/misc.h	Tue Jan  2 20:57:58 2001
***************
*** 112,115 ****
--- 112,116 ----
  extern SLKeyMap_List_Type *Slrn_Current_Keymap;
  
  extern int Slrn_Abort_Unmodified;
+ extern int Slrn_Clock_In_Top_Status_Line;
  #endif				       /* _SLRN_MISC_H */
diff -cr slrn-0.9.6.3.orig/src/nntp.c slrn-0.9.6.3/src/nntp.c
*** slrn-0.9.6.3.orig/src/nntp.c	Mon Sep 18 00:35:32 2000
--- slrn-0.9.6.3/src/nntp.c	Tue Jan  2 21:08:28 2001
***************
*** 299,304 ****
--- 299,315 ----
     return nntp_next_cmd (NNTP_Server, id);
  }
  
+ static int _nntp_get_bytes(int clear)
+ {
+    int temp;
+    
+    temp = NNTP_Server->number_bytes_received;
+    if (clear)
+      NNTP_Server->number_bytes_received = 0;
+    
+    return temp;
+ }
+ 
  static int nntp_init_objects (void)
  {
     NNTP_Post_Obj.po_start = _nntp_start_post;
***************
*** 325,330 ****
--- 336,342 ----
     NNTP_Server_Obj.sv_nntp_head = _nntp_head_cmd;
     NNTP_Server_Obj.sv_nntp_next = _nntp_next_cmd;
     NNTP_Server_Obj.sv_reset = _nntp_reset;
+    NNTP_Server_Obj.sv_nntp_bytes = _nntp_get_bytes;
     return 0;
  }
  
***************
*** 412,417 ****
--- 424,431 ----
  		  NNTP_Debug_Fp = fopen (arg1, "w");
  		  if (NNTP_Debug_Fp == NULL)
  		    slrn_exit_error ("Unable to open %s for debugging.", arg1);
+ 		  else
+ 		    setbuf (NNTP_Debug_Fp, (char*) NULL);
  	       }
  	     else break;
  
diff -cr slrn-0.9.6.3.orig/src/nntplib.c slrn-0.9.6.3/src/nntplib.c
*** slrn-0.9.6.3.orig/src/nntplib.c	Mon Sep 18 00:35:31 2000
--- slrn-0.9.6.3/src/nntplib.c	Tue Jan  2 20:59:49 2001
***************
*** 151,156 ****
--- 151,160 ----
       return -1;
  
     len = strlen (buf);
+ 
+    /* Update bytes received */
+    s->number_bytes_received += len;
+    
     if (len && (buf[len - 1] == '\n'))
       {
  	len--;
***************
*** 407,412 ****
--- 411,417 ----
       return -1;
  
     s->init_state = 1;
+    s->number_bytes_received = 0;
  
     /* Read logon message. */
     switch (nntp_get_server_response (s))
***************
*** 724,729 ****
--- 729,740 ----
  {
     int estim;
     int min, max;
+    
+    /* When re-selecting the current group, inn does not update the high
+     * water mark. A reconnect is the only way I know to work around this. */
+    if (!strcmp(s->group_name, name) &&
+        (-1 == nntp_reconnect_server (s)))
+      return -1;
  
     switch (nntp_server_vcmd (s, "GROUP %s", name))
       {
diff -cr slrn-0.9.6.3.orig/src/nntplib.h slrn-0.9.6.3/src/nntplib.h
*** slrn-0.9.6.3.orig/src/nntplib.h	Mon Sep 18 00:35:31 2000
--- slrn-0.9.6.3/src/nntplib.h	Tue Jan  2 20:59:49 2001
***************
*** 43,48 ****
--- 43,50 ----
     
     int (*auth_hook)(char *, char **, char **);
  
+    int number_bytes_received;
+ 
     SLTCP_Type *tcp;
  }
  NNTP_Type;
diff -cr slrn-0.9.6.3.orig/src/post.c slrn-0.9.6.3/src/post.c
*** slrn-0.9.6.3.orig/src/post.c	Mon Sep 18 00:35:28 2000
--- slrn-0.9.6.3/src/post.c	Tue Jan  2 21:01:46 2001
***************
*** 67,76 ****
--- 67,78 ----
  char *Slrn_Last_Message_Id;
  char *Slrn_Post_Custom_Headers;
  char *Slrn_Failed_Post_Filename;
+ char *Slrn_Signoff_String;
  
  int Slrn_Reject_Long_Lines = 1;
  char *Slrn_Postpone_Dir;
  int Slrn_Generate_Message_Id = 1;
+ int Slrn_Smart_Quote = 0;
  
  static int postpone_file (char *);
  
***************
*** 147,161 ****
     FILE *sfp;
     char file[SLRN_MAX_PATH_LEN];
     char buf [256];
     
     if ((Slrn_User_Info.signature == NULL)
         || (Slrn_User_Info.signature[0] == 0))
       return;
! 
     if ((sfp = slrn_open_home_file (Slrn_User_Info.signature, "r", file, 0)) != NULL)
       {
  	/* Apparantly some RFC suggests the -- \n. */
!         fputs ("\n\n-- \n", fp);
  	
  	/* If signature file already has -- \n, do not add it. */
  	if ((NULL != fgets (buf, sizeof (buf), sfp))
--- 149,172 ----
     FILE *sfp;
     char file[SLRN_MAX_PATH_LEN];
     char buf [256];
+ 
+    if (Slrn_Signoff_String)
+      {
+         fputs ("\n", fp);
+         fputs (Slrn_Signoff_String, fp);
+      }
     
     if ((Slrn_User_Info.signature == NULL)
         || (Slrn_User_Info.signature[0] == 0))
       return;
!    
     if ((sfp = slrn_open_home_file (Slrn_User_Info.signature, "r", file, 0)) != NULL)
       {
+  	if (! Slrn_Signoff_String)
+  	  fputs ("\n", fp);
+ 	
  	/* Apparantly some RFC suggests the -- \n. */
!         fputs ("\n-- \n", fp);
  	
  	/* If signature file already has -- \n, do not add it. */
  	if ((NULL != fgets (buf, sizeof (buf), sfp))
diff -cr slrn-0.9.6.3.orig/src/post.h slrn-0.9.6.3/src/post.h
*** slrn-0.9.6.3.orig/src/post.h	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/post.h	Tue Jan  2 21:02:09 2001
***************
*** 31,33 ****
--- 31,35 ----
  extern int Slrn_Reject_Long_Lines;
  extern char *Slrn_Postpone_Dir;
  extern int Slrn_Generate_Message_Id;
+ extern int Slrn_Smart_Quote;
+ extern char *Slrn_Signoff_String;
diff -cr slrn-0.9.6.3.orig/src/score.c slrn-0.9.6.3/src/score.c
*** slrn-0.9.6.3.orig/src/score.c	Mon Sep 18 00:35:26 2000
--- slrn-0.9.6.3/src/score.c	Tue Jan  2 21:19:53 2001
***************
*** 75,80 ****
--- 75,84 ----
  #define SCORE_LINES 6
  #define SCORE_MESSAGE_ID 7
  #define SCORE_DATE 8
+ #define SCORE_AGE 9
+ #define SCORE_SUB_AND 10
+ #define SCORE_SUB_OR 11
+ 
     /* generic requires extra server interaction */
  #define SCORE_GENERIC 16
     unsigned int flags;
***************
*** 84,89 ****
--- 88,94 ----
       {
  	unsigned char *regexp_str;
  	int ival;
+ 	struct PScore_Regexp_Type *psrt;
       }
     ireg;
     struct PScore_Regexp_Type *next;
***************
*** 120,125 ****
--- 125,131 ----
  	int ival;		       /* used by certain headers */
  	Our_SLRegexp_Type re;
  	SLsearch_Type se;
+ 	struct Score_Regexp_Type *srt;
       }
     search;
     struct Score_Regexp_Type *next;
***************
*** 161,173 ****
  
  int Slrn_Apply_Score = 1;
  
  int slrn_score_header (Slrn_Header_Type *h, char *newsgroup)
  {
     Score_Type *st;
     int score = 0;
!    char *s;
!    int ival = 0;
!    
  #ifndef SLRNPULL_CODE
  #if SLRN_HAS_MSGID_CACHE
     s = slrn_is_msgid_cached (h->msgid, newsgroup, 1);
--- 167,388 ----
  
  int Slrn_Apply_Score = 1;
  
+ int match_srt (Slrn_Header_Type *h, Score_Regexp_Type *srt, char *newsgroup,
+     		int or_type) /* returns 1 on match 0 if failed*/
+ {
+    char *s= NULL;
+    int ival = 0;
+    unsigned int len;
+ #ifndef SLRNPULL_CODE
+    char buf[1024];
+ #endif
+ 
+    while (srt != NULL)
+      {
+         switch (srt->header_type)
+           {
+            case SCORE_LINES:
+ 	     ival = h->lines;
+ 	     goto integer_compare;/* ugly, ugly, ugly!! */
+ 		  
+            case SCORE_SUBJECT:
+              s = h->subject;
+              break;
+ 
+            case SCORE_FROM:
+              s = h->from;
+              break;
+ 
+            case SCORE_DATE:
+              s = h->date;
+              break;
+ 	     
+ 	   case SCORE_AGE:
+ 	     ival = slrn_date_to_order_parm(h->date);
+ 	     goto integer_compare;
+ 	     
+            case SCORE_MESSAGE_ID:
+              s = h->msgid;
+              break;
+ 
+            case SCORE_XREF:
+              s = h->xref;
+              break;
+ 
+            case SCORE_REFERENCES:
+              s = h->refs;
+              break;
+ 
+            case SCORE_NEWSGROUP:
+              s = newsgroup;
+              break;
+ 
+            case SCORE_GENERIC:
+ #ifdef SLRNPULL_CODE
+              s = slrn_get_extra_xover_header (srt->generic_keyword);
+ #else
+ 
+              /* Yuk.  This will be slow! */
+              if (Slrn_Score_After_XOver)
+                {
+                   if (((Slrn_Perform_Scoring & SLRN_EXPENSIVE_SCORING) == 0)
+                       || (-1 == Slrn_Server_Obj->sv_xhdr_command
+ 			(srt->generic_keyword, h->number, buf, sizeof(buf))))
+                          s = NULL;
+                   else s = buf;
+                }
+              else
+                {
+                   if (Slrn_Perform_Scoring & SLRN_EXPENSIVE_SCORING)
+                     s = slrn_get_extra_xover_header (srt->generic_keyword);
+ 		  else s = NULL;
+                }
+ #endif
+              break;
+ 
+            case SCORE_SUB_AND:
+              if (match_srt(h, srt->search.srt, newsgroup, 0))
+ 	       { /* sub matchs */
+                   if (srt->not_flag)
+                     {
+                        if (or_type) goto next_srt;
+                        return 0;
+                     }
+                }
+              else /* sub matchs not */
+ 	       {
+ 		 if (srt->not_flag == 0)
+                    {
+                       if (or_type) goto next_srt;
+                       return 0;
+                    }
+ 	       }
+ 	     if (or_type) return 1;
+ 	     goto next_srt;
+              break;
+ 
+ 	   case SCORE_SUB_OR:
+              if (match_srt(h, srt->search.srt, newsgroup, 1))
+                { /* sub matchs */
+                   if (srt->not_flag)
+                     {
+                        if (or_type) goto next_srt;
+                        return 0;
+                     }
+                }
+              else /* sub matchs not */
+ 	       {
+ 		 if (srt->not_flag == 0)
+                    {
+                       if (or_type) goto next_srt;
+                       return 0;
+                    }
+ 	       }
+              if (or_type) return 1;
+ 	     goto next_srt;
+              break;
+            default:
+              s = NULL;            /* not supposed to happen */
+           } /*switch (srt->header_type)*/
+ 
+         if (s == NULL)
+           {
+              if (srt->not_flag)
+                {
+                   /* Match */
+                   if (or_type)
+                     return 1;
+                    goto next_srt;
+                }
+ 
+              /* Match failed */
+              if (or_type) goto next_srt;
+              return 0;
+           }
+ 
+         len = strlen (s);
+ 
+         if (srt->do_osearch)
+           {
+              SLsearch_Type *se = &srt->search.se;
+ 
+ 	     if ((len < (unsigned int) se->key_len)
+                       || (NULL == SLsearch ((unsigned char *) s,
+                                             (unsigned char *) s + len,
+                                             se)))
+                {/*expr matchs not*/
+                   if (srt->not_flag == 0)
+                     {
+                        if (or_type) goto next_srt;
+                        return 0;
+                     }
+                }
+              else if (srt->not_flag)
+                {
+                   if (or_type) goto next_srt;
+                   return 0;
+                }
+           }
+         else
+           {
+              SLRegexp_Type *re;
+ 
+              re = &srt->search.re.regexp;
+              if ((len < re->min_length)
+                  || (NULL == SLang_regexp_match ((unsigned char *)s, len, re)))
+                {
+                   if (srt->not_flag == 0)
+                     {
+                        if (or_type) goto next_srt;
+                        return 0;
+                     }
+                }
+              else if (srt->not_flag)
+                {
+                   if (or_type) goto next_srt;
+                   return 0;
+                }
+           }
+         /* Get here if above matched */
+         if (or_type) return 1;
+ 	srt = srt->next;
+ 	continue;
+ 	
+ 	/* This is ugly but I am worried about speed. --- we only get
+ 	 * here for those headers that have integer values.
+ 	 */
+ 	integer_compare:
+ 	if (ival < srt->search.ival)
+ 	  {
+ 	     if (srt->not_flag == 0)
+ 	       {
+ 		  if (or_type) goto next_srt;
+ 		  return 0;
+ 	       }
+ 	  }
+ 	else if (srt->not_flag)
+ 	  {
+ 	     if (or_type) goto next_srt;
+ 	     return 0;
+ 	  }
+ 	
+ 	/* If we get here, the regular expression matched. */
+ 	if (or_type) return 1;
+ 	
+ 	next_srt:
+         srt = srt->next;
+      } /*while (srt != NULL)*/
+    if (or_type) return 0;
+    else return 1;
+ }
+ 
  int slrn_score_header (Slrn_Header_Type *h, char *newsgroup)
  {
     Score_Type *st;
     int score = 0;
!    char *s= NULL;
!    int or_type;
!    Score_Regexp_Type *srt;
  #ifndef SLRNPULL_CODE
  #if SLRN_HAS_MSGID_CACHE
     s = slrn_is_msgid_cached (h->msgid, newsgroup, 1);
***************
*** 180,377 ****
  #endif
  #endif				       /* NOT SLRNPULL_CODE */
     
-    s = NULL;
- 
     st = Score_Root;
     while (st != NULL)
       {
! 	unsigned int len;
! 	Score_Regexp_Type *srt = &st->regexp_list;
! #ifndef SLRNPULL_CODE
! 	char buf[1024];
! #endif
! 	int or_type = st->pscore->flags & SCORE_IS_OR_TYPE;
! 	
! 	while (srt != NULL)
! 	  {
! 	     switch (srt->header_type)
! 	       {
! 		case SCORE_LINES:
! 		  ival = h->lines;
! 		  goto integer_compare;/* ugly, ugly, ugly!! */
! 		  
! 		case SCORE_SUBJECT:
! 		  s = h->subject;
! 		  break;
! 		  
! 		case SCORE_FROM:
! 		  s = h->from;
! 		  break;
! 		  
! 		case SCORE_DATE:
! 		  s = h->date;
! 		  break;
! 
! 		case SCORE_MESSAGE_ID:
! 		  s = h->msgid;
! 		  break;
! 		  
! 		case SCORE_XREF:
! 		  s = h->xref;
! 		  break;
! 		  
! 		case SCORE_REFERENCES:
! 		  s = h->refs;
! 		  break;
! 		  
! 		case SCORE_NEWSGROUP:
! 		  s = newsgroup;
! 		  break;
! 		  
! 		case SCORE_GENERIC:
! #ifdef SLRNPULL_CODE
! 		  s = slrn_get_extra_xover_header (srt->generic_keyword);
! #else
! 		  
! 		  /* Yuk.  This will be slow! */
! 		  if (Slrn_Score_After_XOver)
! 		    {
! 		       if (((Slrn_Perform_Scoring & SLRN_EXPENSIVE_SCORING) == 0)
! 			   || (-1 == Slrn_Server_Obj->sv_xhdr_command (srt->generic_keyword,
! 							h->number, buf, sizeof(buf))))
! 			 s = NULL;
! 		       else s = buf;
! 		    }
! 		  else
! 		    {
! 		       if (Slrn_Perform_Scoring & SLRN_EXPENSIVE_SCORING)
! 			 s = slrn_get_extra_xover_header (srt->generic_keyword);
! 		       else s = NULL;
! 		    }
! #endif
! 		  break;
! 		  
! 		default:
! 		  s = NULL;	       /* not supposed to happen */
! 	       }
! 	     
! 	     if (s == NULL)
! 	       {
! 		  if (srt->not_flag)
! 		    {
! 		       /* Match */
! 		       if (or_type)
! 			 break;
! 		       
! 		       goto next_srt;
! 		    }
! 		  
! 		  /* Match failed */
! 		  if (or_type) goto next_srt;
! 		  break;
! 	       }
! 	     
! 	     len = strlen (s);
! 	     
! 	     if (srt->do_osearch)
! 	       {
! 		  SLsearch_Type *se = &srt->search.se;
! 		  
! 		  if ((len < (unsigned int) se->key_len)
! 		      || (NULL == SLsearch ((unsigned char *) s,
! 					    (unsigned char *) s + len,
! 					    se)))
! 		    {
! 		       if (srt->not_flag == 0)
! 			 {
! 			    if (or_type) goto next_srt;
! 			    break;
! 			 }
! 		    }
! 		  else if (srt->not_flag)
! 		    {
! 		       if (or_type) goto next_srt;
! 		       break;
! 		    }
! 	       }
! 	     else
! 	       {
! 		  SLRegexp_Type *re;
! 		  
! 		  re = &srt->search.re.regexp;
! 		  if ((len < re->min_length)
! 		      || (NULL == SLang_regexp_match ((unsigned char *)s, len, re)))
! 		    {
! 		       if (srt->not_flag == 0)
! 			 {
! 			    if (or_type) goto next_srt;
! 			    break;
! 			 }
! 		    }
! 		  else if (srt->not_flag)
! 		    {
! 		       if (or_type) goto next_srt;
! 		       break;
! 		    }
! 	       }
! 	     /* Get here if above matched */
! 	     if (or_type) break;
! 	     srt = srt->next;
! 	     continue;
! 	     
! 	     /* This is ugly but I am worried about speed. --- we only get
! 	      * here for those headers that have integer values.
! 	      */
! 	     integer_compare:
! 	     if (ival < srt->search.ival)
! 	       {
! 		  if (srt->not_flag == 0)
! 		    {
! 		       if (or_type) goto next_srt;
! 		       break;
! 		    }
! 	       }
! 	     else if (srt->not_flag)
! 	       {
! 		  if (or_type) goto next_srt;
! 		  break;
! 	       }
! 	     
! 	     /* If we get here, the regular expression matched. */
! 	     if (or_type) break;
! 	     
! 	     next_srt:
! 	     srt = srt->next;
! 	  }
  	
! 	if (((srt == NULL) && (or_type == 0))
! 	    || (or_type && (srt != NULL)))
! 	  {
! 	     int st_score = st->pscore->score;
  	     
! 	     if (st->pscore->flags & RETURN_THIS_SCORE)
! 	       return st_score;
  	     
! 	     if ((st_score == 9999)
! 		 || (st_score == -9999))
! 	       return st_score;
  	     
! 	     if (st_score == 0)
! 	       return score;
  	     
! 	     score += st_score;
! 	  }
  	
  	st = st->next;
!      }
     return score;
  }
  
  
  static int chain_group_regexp (PScore_Type *pst, int *generic)
  {
     PScore_Regexp_Type *psrt;
!    Score_Regexp_Type *srt;
     Score_Type *st;
     SLRegexp_Type *re;
     
--- 395,494 ----
  #endif
  #endif				       /* NOT SLRNPULL_CODE */
     
     st = Score_Root;
     while (st != NULL)
       {
! 	srt = &st->regexp_list;
! 	or_type = st->pscore->flags & SCORE_IS_OR_TYPE;
  	
!         if (match_srt(h, srt, newsgroup, or_type))
!           {
! 	  int st_score = st->pscore->score;
  	     
! 	  if (st->pscore->flags & RETURN_THIS_SCORE)
! 	    return st_score;
  	     
! 	  if ((st_score == 9999)
! 		|| (st_score == -9999))
! 	    return st_score;
  	     
! 	  if (st_score == 0)
! 	    return score;
  	     
! 	  score += st_score;
! 	}
  	
  	st = st->next;
!      } /*while (st != NULL)*/
     return score;
  }
  
+ int compile_psrt(PScore_Regexp_Type *psrt, Score_Regexp_Type *srt, int *generic)
+ {
+    SLRegexp_Type *re;
+ 
+    while (psrt != NULL)
+      {
+         unsigned int flags = psrt->flags;
+ 
+         if (SCORE_GENERIC == (srt->header_type = psrt->header_type))
+           {
+              *generic += 1;
+           }
+ 
+         srt->not_flag = (0 != (flags & NOT_FLAG));
+ 	  
+ 	if ((srt->header_type == SCORE_SUB_AND) || 
+ 		(srt->header_type == SCORE_SUB_OR))
+ 	  {
+              srt->search.srt = (Score_Regexp_Type *) slrn_malloc (sizeof (Score_Regexp_Type), 1, 0);
+              if (srt->search.srt == NULL) return -1;
+ 
+ 	     if (compile_psrt(psrt->ireg.psrt, srt->search.srt, generic) != 0)
+ 	       return -1;
+           }
+ 	else
+ 	  {
+              srt->generic_keyword = psrt->keyword;
+ 
+ 	     if (flags & USE_INTEGER)
+                {
+                   srt->search.ival = psrt->ireg.ival;
+                }
+              else
+                {
+                   re = &srt->search.re.regexp;
+                   re->pat = psrt->ireg.regexp_str;
+                   re->buf = srt->search.re.buf;
+                   re->buf_len = sizeof (srt->search.re.buf);
+                   re->case_sensitive = 0;
+ 
+                   if (0 != SLang_regexp_compile(re))
+                     {
+                        return -1;
+                     }
+ 
+                   /* If an ordinary search is ok, use it. */
+                   if (re->osearch)
+                     {
+                        srt->do_osearch = 1;
+                        SLsearch_init ((char *) psrt->ireg.regexp_str, 1, 0, &srt->search.se);
+                     }
+                }
+           }
+         psrt = psrt->next;
+         if (psrt == NULL) break;
+ 
+         srt->next = (Score_Regexp_Type *) slrn_malloc (sizeof (Score_Regexp_Type), 1, 0);
+         if (NULL == (srt = srt->next)) return -1;
+      } /* while (psrt != NULL)*/
+    return 0;
+ }
  
  static int chain_group_regexp (PScore_Type *pst, int *generic)
  {
     PScore_Regexp_Type *psrt;
!    Score_Regexp_Type *srt, *save_srt;
     Score_Type *st;
     SLRegexp_Type *re;
     
***************
*** 394,444 ****
  	psrt = pst->pregexp_list;
  	srt = &st->regexp_list;
  	
! 	while (psrt != NULL)
! 	  {
! 	     unsigned int flags = psrt->flags;
! 	     
! 	     if (SCORE_GENERIC == (srt->header_type = psrt->header_type))
! 	       *generic += 1;
! 	     
! 	     srt->generic_keyword = psrt->keyword;
! 	     srt->not_flag = (0 != (flags & NOT_FLAG));
! 	     
! 	     if (flags & USE_INTEGER)
! 	       {
! 		  srt->search.ival = psrt->ireg.ival;
! 	       }
! 	     else
! 	       {
! 		  re = &srt->search.re.regexp;
! 		  re->pat = psrt->ireg.regexp_str;
! 		  re->buf = srt->search.re.buf;
! 		  re->buf_len = sizeof (srt->search.re.buf);
! 		  re->case_sensitive = 0;
! 		  
! 		  if (0 != SLang_regexp_compile (re))
! 		    {
! 		       return -1;
! 		    }
! 		  
! 		  /* If an ordinary search is ok, use it. */
! 		  if (re->osearch)
! 		    {
! 		       srt->do_osearch = 1;
! 		       SLsearch_init ((char *) psrt->ireg.regexp_str, 1, 0, &srt->search.se);
! 		    }
! 	       }
! 	     
! 	     psrt = psrt->next;
! 	     if (psrt == NULL) break;
! 	     
! 	     srt->next = (Score_Regexp_Type *) slrn_malloc (sizeof (Score_Regexp_Type),
! 							    1, 0);
! 	     if (NULL == (srt = srt->next))
! 	       return -1;
! 	  }
  	pst = pst->next;
!      }
     return 0;
  }
  
--- 511,521 ----
  	psrt = pst->pregexp_list;
  	srt = &st->regexp_list;
  	
! 	if (compile_psrt(psrt, srt, generic) != 0)
! 	  return -1;
! 	
  	pst = pst->next;
!      } /* while (pst != NULL) */
     return 0;
  }
  
***************
*** 538,586 ****
  
  
  
! static int add_group_regexp (PScore_Type *pst,
! 			     unsigned char *str,
! 			     unsigned char *keyword, unsigned int type, int not_flag)
  {
     unsigned int len;
-    PScore_Regexp_Type *psrt;
-    
     *str++ = 0;			       /* null terminate keyword by zeroing
  					* out the colon.  This is by agreement
  					* with the calling routine.
  					*/
     
!    if (*str == ' ') str++;	       /* space following colon not meaningful */
  
!    len = (unsigned int) (slrn_trim_string ((char *) str) - (char *) str);
!    if (0 == len) return -1;
!    
!    psrt = (PScore_Regexp_Type *) slrn_safe_malloc (sizeof (PScore_Regexp_Type));
     
!    if (type != SCORE_LINES)
!      psrt->ireg.regexp_str = (unsigned char *) slrn_safe_strmalloc ((char *)str);
!    else
       {
! 	psrt->ireg.ival = atoi((char *)str);
! 	psrt->flags |= USE_INTEGER;
       }
     
!    psrt->header_type = type;
!    strncpy (psrt->keyword, (char *) keyword, MAX_KEYWORD_LEN);
!    psrt->keyword[MAX_KEYWORD_LEN - 1] = 0;
     
     if (not_flag) psrt->flags |= NOT_FLAG;
     psrt->next = NULL;
!    if (pst->pregexp_list == NULL)
!      {
! 	pst->pregexp_list = psrt;
!      }
!    else
!      {
! 	PScore_Regexp_Type *last = pst->pregexp_list;
! 	while (last->next != NULL) last = last->next;
! 	last->next = psrt;
!      }
     return 0;
  }
  
--- 615,660 ----
  
  
  
! static int add_group_regexp (PScore_Regexp_Type *psrt, unsigned char *str,
! 			     unsigned char *keyword, unsigned int type,
! 			     int not_flag)
  {
     unsigned int len;
     *str++ = 0;			       /* null terminate keyword by zeroing
  					* out the colon.  This is by agreement
  					* with the calling routine.
  					*/
     
!    if (*str == ' ') str++;       /* space following colon not meaningful */
  
!    psrt->header_type = type;
!    if ((type != SCORE_SUB_AND) && (type != SCORE_SUB_OR)) {
     
!      len = (unsigned int) (slrn_trim_string ((char *) str) - (char *) str);
!      if (0 == len) return -1;
!       
!      if (type == SCORE_LINES) {
!        psrt->ireg.ival = atoi((char *)str);
!        psrt->flags |= USE_INTEGER;
!      }
!      else if (type == SCORE_AGE)
       {
!  	psrt->ireg.ival = time(NULL) - atoi((char *)str) * 86400;
!  	psrt->flags |= USE_INTEGER;
       }
+      else
+       psrt->ireg.regexp_str = (unsigned char *) slrn_safe_strmalloc ((char *)str);
     
!      strncpy (psrt->keyword, (char *) keyword, MAX_KEYWORD_LEN);
!      psrt->keyword[MAX_KEYWORD_LEN - 1] = 0;
!    } else {
!      psrt->ireg.psrt = NULL;
!    }
     
+ 
     if (not_flag) psrt->flags |= NOT_FLAG;
     psrt->next = NULL;
!    
     return 0;
  }
  
***************
*** 857,980 ****
  	return -1;
       }
  
!    while (fgets (line, sizeof (line) - 1, fp))
       {
  	unsigned char *lp;
  	int not_flag;
  
! 	linenum++;
! 
  	if (0 == SLprep_line_ok (line, &c->pt))
  	  continue;
  
  	lp = (unsigned char *) slrn_skip_whitespace (line);
  	if ((*lp == '#') || (*lp == '%') || (*lp <= ' ')) continue;
  
! 	if ((0 == slrn_case_strncmp (lp, (unsigned char *) "include", 7))
! 	    && ((lp[7] == ' ') || (lp[7] == '\t')))
! 	  {
! 	     if (0 == handle_include_line (file, (char *)lp + 7, c))
! 	       continue;
! 	     
! 	     score_error ("Error handling INCLUDE line", line, linenum, file);
! 	     goto error_return;
! 	  }
! 
! 	if (*lp == '[')
! 	  {
! 	     unsigned char *g, *gmax, ch;
! 	     g = c->group;
! 	     gmax = g + sizeof (c->group);
! 	     
! 	     lp++;
! 	     lp = (unsigned char *) slrn_skip_whitespace ((char *)lp);
! 	     
! 	     c->gnt_not_flag = 0;
! 	     if (*lp == '~')
! 	       {
! 		  c->gnt_not_flag = 1;
! 		  lp = (unsigned char *) slrn_skip_whitespace ((char *)lp + 1);
! 	       }
! 	     
! 	     while (((ch = *lp++) != 0)
! 		    && (ch != ']') && (g < gmax))
! 	       *g++ = ch;
! 	     
! 	     if ((ch != ']') || (g == gmax))
! 	       {
! 		  score_error ("Syntax Error.", line, linenum, file);
! 		  goto error_return;
! 	       }
! 	     *g = 0;
! 	     c->start_new_group = 1;
! 	     c->score_has_expired = 0;
! 	     c->start_new_score = 0;
! 	     continue;
! 	  }
! 
! 	if (!slrn_case_strncmp (lp, (unsigned char *)"Score:", 6))
! 	  {
! 	     unsigned char *lpp = lp + 6;
! 	     c->pscore_flags = 0;
! 	     if (*lpp == ':')
! 	       {
! 		  lpp++;
! 		  c->pscore_flags |= SCORE_IS_OR_TYPE;
! 	       }
! 	     lpp = (unsigned char *) slrn_skip_whitespace ((char *) lpp);
! 	     if (*lpp == '=')
! 	       {
! 		  c->pscore_flags |= RETURN_THIS_SCORE;
! 		  lpp++;
! 	       }
! 	     c->score = atoi ((char *)lpp);
! 	     c->start_new_score = 1;
! 	     continue;
! 	  }
! 
! 	if (c->start_new_score)
  	  {
! 	     if (!slrn_case_strncmp (lp, (unsigned char *) "Expires:", 8))
! 	       {
! 		  int ret;
! 		  ret = has_score_expired (lp + 8, c->today);
! 		  if (ret == -1)
! 		    {
! 		       score_error ("Expecting 'Expires: MM/DD/YYYY' or 'Expires: DD-MM-YYYY'",
! 				    line, linenum, file);
! 		       goto error_return;
! 		    }
! 		  if (ret)
! 		    {
! 		       slrn_message ("%s has expired score on line %d",
! 				     file, linenum);
! 		       c->start_new_score = 0;
! 		       c->score_has_expired = 1;
! 		    }
! 		  else c->score_has_expired = 0;
! 		  continue;
! 	       }
  
- 	     
- 	     if (NULL == (c->pst = create_new_score (c->group, c->start_new_group, c->gnt_not_flag,
- 						     c->score, c->pscore_flags)))
- 	       {
- 		  score_error ("Bad group regular expression.", line, linenum, file);
- 		  goto error_return;
- 	       }
- 	     c->start_new_group = 0;
- 	     c->start_new_score = 0;
- 	     c->score_has_expired = 0;
- 	  }
- 	
- 	if (c->score_has_expired) continue;
- 	
- 	if (c->pst == NULL)
- 	  {
- 	     score_error ("Expecting Score keyword.", line, linenum, file);
- 	     goto error_return;
- 	  }
- 	
  	if (*lp == '~')
  	  {
  	     not_flag = 1;
--- 931,1079 ----
  	return -1;
       }
  
!    if (phrase_score_file(file, fp, c, &linenum, NULL) == -1)
!      {
! 	fclose (fp);
! 	return -1;
!      }
!    fclose (fp);
!    return 0;
! }
! 
! int phrase_score_file (char *file, FILE *fp, Score_Context_Type *c,
! 			int *linenum, PScore_Regexp_Type *sub_psrt)
! {
!     char line[1024];
!     PScore_Regexp_Type *psrt;
!     
!     while (fgets (line, sizeof (line) - 1, fp))
       {
  	unsigned char *lp;
  	int not_flag;
+         
+ 	
+ 	(*linenum)++;
  
! 	psrt = NULL;
! 	
  	if (0 == SLprep_line_ok (line, &c->pt))
  	  continue;
  
  	lp = (unsigned char *) slrn_skip_whitespace (line);
  	if ((*lp == '#') || (*lp == '%') || (*lp <= ' ')) continue;
  
! 	if (sub_psrt == NULL)
  	  {
! 	    if ((0 == slrn_case_strncmp (lp, (unsigned char *) "include", 7))
! 	        && ((lp[7] == ' ') || (lp[7] == '\t')))
! 	      {
! 	         if (0 == handle_include_line (file, (char *)lp + 7, c))
! 	         continue;
! 	     
! 	         score_error ("Error handling INCLUDE line", line, *linenum,
! 		     		file);
! 	         return -1;
! 	      }
! 
! 	    if (*lp == '[')
! 	      {
! 	         unsigned char *g, *gmax, ch;
! 	         g = c->group;
! 	         gmax = g + sizeof (c->group);
! 	     
!     	         lp++;
!     	         lp = (unsigned char *) slrn_skip_whitespace ((char *)lp);
!     	     
!     	         c->gnt_not_flag = 0;
!     	         if (*lp == '~')
!     	           {
!     		      c->gnt_not_flag = 1;
!     		      lp = (unsigned char *) slrn_skip_whitespace ((char *)lp + 1);
!     	           }
!     	     
!     	         while (((ch = *lp++) != 0)
!     		        && (ch != ']') && (g < gmax))
!     	           *g++ = ch;
!     	     
!     	         if ((ch != ']') || (g == gmax))
!     	           {
!     		      score_error ("Syntax Error.", line, *linenum, file);
!     		      return -1;
!     	           }
!     	         *g = 0;
!     	         c->start_new_group = 1;
!     	         c->score_has_expired = 0;
!     	         c->start_new_score = 0;
!     	         continue;
!               }
!         
! 	    if (!slrn_case_strncmp (lp, (unsigned char *)"Score:", 6))
!               {
!                  unsigned char *lpp = lp + 6;
!                  c->pscore_flags = 0;
!                  if (*lpp == ':')
!                    {
! 		      lpp++;
!         	      c->pscore_flags |= SCORE_IS_OR_TYPE;
!         	   }
!         	 lpp = (unsigned char *) slrn_skip_whitespace ((char *) lpp);
!         	 if (*lpp == '=')
!         	   {
!         	      c->pscore_flags |= RETURN_THIS_SCORE;
!         	      lpp++;
!         	   }
!         	 c->score = atoi ((char *)lpp);
!         	 c->start_new_score = 1;
!         	 continue;
!               }
!         
!             if (c->start_new_score)
!               {
!         	 if (!slrn_case_strncmp (lp, (unsigned char *) "Expires:", 8))
!         	   {
!         	      int ret;
!         	      ret = has_score_expired (lp + 8, c->today);
!         	      if (ret == -1)
!         	        {
!         	            score_error ("Expecting 'Expires: MM/DD/YYYY' or 'Expires: DD-MM-YYYY'",
!         				   line, *linenum, file);
!         		    return -1;
!         		}
!         	      if (ret)
!         		{
!         		   slrn_message ("%s has expired score on line %d",
!         				     file, *linenum);
!         		   c->start_new_score = 0;
!         		   c->score_has_expired = 1;
!         		}
!         	     else c->score_has_expired = 0;
!         	     continue;
!         	   }
!         
!         	     
!         	 if (NULL == (c->pst = create_new_score (c->group,
! 			   	c->start_new_group, c->gnt_not_flag,
!         			c->score, c->pscore_flags)))
!         	   {
!         	      score_error ("Bad group regular expression.", line,
! 			    		*linenum, file);
!         	      return -1;
!         	   }
!         	 c->start_new_group = 0;
!         	 c->start_new_score = 0;
!         	 c->score_has_expired = 0;
!               }
!         	
! 	    if (c->score_has_expired) continue;
!         	
!             if (c->pst == NULL)
!               {
!                  score_error ("Expecting Score keyword.", line, *linenum, file);
!         	 return -1;
!               }
!         	 
! 	  } /*if (sub_psrt==null) */
  
  	if (*lp == '~')
  	  {
  	     not_flag = 1;
***************
*** 982,1024 ****
  	  }
  	else not_flag = 0;
  
  	/* Otherwise the line is a kill one */
  	if (!slrn_case_strncmp (lp, (unsigned char *)"Subject:", 8))
! 	  add_group_regexp (c->pst, lp + 7, lp, SCORE_SUBJECT, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"From:", 5))
! 	  add_group_regexp (c->pst, lp + 4, lp, SCORE_FROM, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Xref:", 5))
! 	  add_group_regexp (c->pst, lp + 4, lp, SCORE_XREF, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Newsgroup:", 10))
! 	  add_group_regexp (c->pst, lp + 9, lp, SCORE_NEWSGROUP, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"References:", 11))
! 	  add_group_regexp (c->pst, lp + 10, lp, SCORE_REFERENCES, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Lines:", 6))
! 	  add_group_regexp (c->pst, lp + 5, lp, SCORE_LINES, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Date:", 5))
! 	  add_group_regexp (c->pst, lp + 5, lp, SCORE_DATE, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Message-Id:", 11))
! 	  add_group_regexp (c->pst, lp + 10, lp, SCORE_MESSAGE_ID, not_flag);
! 	else
  	  {
  	     unsigned char *lpp = lp;
  	     while (*lpp && (*lpp != ':')) lpp++;
  	     if (*lpp != ':')
  	       {
! 		  score_error ("Missing COLON.", line, linenum, file);
! 		  goto error_return;
  	       }
  	     
! 	     add_group_regexp (c->pst, lpp, lp, SCORE_GENERIC, not_flag);
  	  }
!      }
! 
!    fclose (fp);
!    return 0;
! 
!    error_return:
!    fclose (fp);
!    return -1;
  }
  
  			
--- 1081,1174 ----
  	  }
  	else not_flag = 0;
  
+ 	psrt = (PScore_Regexp_Type *) slrn_safe_malloc (sizeof (PScore_Regexp_Type));
  	/* Otherwise the line is a kill one */
  	if (!slrn_case_strncmp (lp, (unsigned char *)"Subject:", 8))
! 	  add_group_regexp (psrt, lp + 7, lp, SCORE_SUBJECT, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"From:", 5))
! 	  add_group_regexp (psrt, lp + 4, lp, SCORE_FROM, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Xref:", 5))
! 	  add_group_regexp (psrt, lp + 4, lp, SCORE_XREF, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Newsgroup:", 10))
! 	  add_group_regexp (psrt, lp + 9, lp, SCORE_NEWSGROUP, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"References:", 11))
! 	  add_group_regexp (psrt, lp + 10, lp, SCORE_REFERENCES, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Lines:", 6))
! 	  add_group_regexp (psrt, lp + 5, lp, SCORE_LINES, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Date:", 5))
! 	  add_group_regexp (psrt, lp + 4, lp, SCORE_DATE, not_flag);
! 	else if (!slrn_case_strncmp (lp, (unsigned char *)"Age:", 4))
! 	  add_group_regexp (psrt, lp + 3, lp, SCORE_AGE, not_flag);
  	else if (!slrn_case_strncmp (lp, (unsigned char *)"Message-Id:", 11))
! 	  add_group_regexp (psrt, lp + 10, lp, SCORE_MESSAGE_ID, not_flag);
!         else if (!slrn_case_strncmp (lp, (unsigned char *)"{:", 1))
! 	  {
!             if (lp[2] ==':')
! 	      {
! 		add_group_regexp (psrt, lp + 1, lp, SCORE_SUB_OR, not_flag);
! 	      }
! 	    else
! 	      {
! 		add_group_regexp (psrt, lp + 1, lp, SCORE_SUB_AND, not_flag);
! 	      }
! 	    if (phrase_score_file(file, fp, c, linenum, psrt))  return -1;
!           }
!         else if (!slrn_case_strncmp (lp, (unsigned char *)"}", 1))
! 	  {
! 	    if (sub_psrt != NULL)
! 	      return 0;
! 	    else
! 	      {
! 	         score_error ("Missing COLON.", line, *linenum, file);
! 	         return -1;
! 	      }
! 	  }
!  	else
  	  {
  	     unsigned char *lpp = lp;
  	     while (*lpp && (*lpp != ':')) lpp++;
  	     if (*lpp != ':')
  	       {
! 		  score_error ("Missing COLON.", line, *linenum, file);
! 		  return -1;
  	       }
  	     
! 	     add_group_regexp (psrt, lpp, lp, SCORE_GENERIC, not_flag);
  	  }
!    
!        if (sub_psrt == NULL)
!          {
!            if (c->pst->pregexp_list == NULL)
!              {
!                 c->pst->pregexp_list = psrt;
!              }
!            else
!              {
!                 PScore_Regexp_Type *last = c->pst->pregexp_list;
!                 while (last->next != NULL) last = last->next;
! 		last->next = psrt;
! 	     }
! 	 }
!        else
!          {
!             if (sub_psrt->ireg.psrt == NULL)
! 	      {
!                 sub_psrt->ireg.psrt = psrt;
!               }
! 	    else
! 	      {
!                  PScore_Regexp_Type *last = sub_psrt->ireg.psrt;
!                  while (last->next != NULL) last = last->next;
!                  last->next = psrt;
!               }
!          }
!      } /*while (fgets (line, sizeof (line) - 1, fp))*/
!   if (sub_psrt == NULL) return 0;
!   else
!     {
!        score_error ("Missing '}' for  subscore", line, *linenum, file);
!        return -1;
!     }
  }
  
  			
diff -cr slrn-0.9.6.3.orig/src/server.h slrn-0.9.6.3/src/server.h
*** slrn-0.9.6.3.orig/src/server.h	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/server.h	Tue Jan  2 20:59:49 2001
***************
*** 60,65 ****
--- 60,70 ----
     int (*sv_nntp_xover) (int, int);
     int (*sv_nntp_head) (int, char *, int *);
     int (*sv_nntp_next) (int *);
+ 
+    /* Returns number of bytes received.
+     * If the int is non-0, it will clear it. */
+    int (*sv_nntp_bytes) (int);
+    
     char *sv_name;
     
  } 
diff -cr slrn-0.9.6.3.orig/src/slrn.c slrn-0.9.6.3/src/slrn.c
*** slrn-0.9.6.3.orig/src/slrn.c	Mon Sep 18 00:35:26 2000
--- slrn-0.9.6.3/src/slrn.c	Tue Jan  2 20:59:15 2001
***************
*** 769,805 ****
  
  /*}}}*/
  
- int slrn_get_new_news (int no_new_groups, int create_flag) /*{{{*/
- {
-    char *msg1 = "Checking for new groups ...";
-    char *msg2 = "Checking news ...";
-    char *msg3 = "Checking news via active file ...";
-    char *msg;
-    
-    if (Slrn_Server_Obj->sv_initialize () != 0) return (-1);
-    
-    if (create_flag == 0)
-      {
- 	if (no_new_groups == 0)
- 	  {
- 	     slrn_message_now (msg1);
- 	     slrn_check_new_groups (create_flag);
- 	  }
- 	
- 	if (Slrn_List_Active_File) msg = msg3;
- 	else msg = msg2;
- 	
- 	slrn_message_now (msg);
-      }
-    slrn_read_newsrc (create_flag);
-    
-    slrn_read_group_descriptions ();
-    
-    return 0;
- }
- 
- /*}}}*/
- 
  static void perform_cleanup (void)
  {
     if (Slrn_Server_Obj != NULL) 
--- 769,774 ----
***************
*** 1134,1140 ****
  
     if (Slrn_Server_Id == 0) Slrn_Server_Id = Slrn_Default_Server_Obj;
     if (Slrn_Post_Id == 0) Slrn_Post_Id = Slrn_Default_Post_Obj;
!    if (Slrn_Check_New_Groups == 0) no_new_groups = 1;
  
  #if SLRN_HAS_CHARACTER_MAP
     if (-1 == slrn_set_charset (Slrn_Charset))
--- 1103,1109 ----
  
     if (Slrn_Server_Id == 0) Slrn_Server_Id = Slrn_Default_Server_Obj;
     if (Slrn_Post_Id == 0) Slrn_Post_Id = Slrn_Default_Post_Obj;
!    if (no_new_groups) Slrn_Check_New_Groups = 0;
  
  #if SLRN_HAS_CHARACTER_MAP
     if (-1 == slrn_set_charset (Slrn_Charset))
***************
*** 1253,1263 ****
  	  }
       }
  #endif
! 	
!    if (-1 == slrn_get_new_news (no_new_groups, create_flag))
       {
  	slrn_exit_error ("Failed to initialize server.");
       }
     
     putc ('\n', stdout);
     
--- 1222,1240 ----
  	  }
       }
  #endif
! 
!    if (Slrn_Server_Obj->sv_initialize () != 0)
       {
  	slrn_exit_error ("Failed to initialize server.");
       }
+    
+    if (Slrn_Check_New_Groups || create_flag)
+      {
+ 	slrn_check_new_groups (create_flag);
+      }
+    
+    slrn_read_newsrc (create_flag);
+    slrn_read_group_descriptions ();
     
     putc ('\n', stdout);
     
diff -cr slrn-0.9.6.3.orig/src/slrn.h slrn-0.9.6.3/src/slrn.h
*** slrn-0.9.6.3.orig/src/slrn.h	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/slrn.h	Tue Jan  2 21:09:19 2001
***************
*** 20,25 ****
--- 20,28 ----
  #ifndef _SLRN_SLRN_H_
  #define _SLRN_SLRN_H_
  #include <slang.h>
+ #ifdef HAVE_LOCALE_H
+ # include <locale.h>
+ #endif
  #include "version.h"
  
  extern int Slrn_TT_Initialized;
***************
*** 35,41 ****
  extern void slrn_push_suspension (int);
  extern void slrn_pop_suspension (void);
  
- extern int  slrn_get_new_news (int, int);
  extern char *Slrn_Newsrc_File;
  #if 0
  extern void (*Slrn_Hangup_Hook) (int);
--- 38,43 ----
***************
*** 69,74 ****
--- 71,78 ----
  extern void slrn_call_command (char *);
  
  extern long slrn_date_to_order_parm (char *);
+ extern void slrn_strftime (char *s, size_t max, const char *format,
+ 			   char *date);
  extern int slrn_parse_helpfile (char *);
  extern void slrn_smg_refresh (void);
  extern void slrn_enable_mouse (int);
***************
*** 85,93 ****
  
  extern int slrn_sys_system (char *);
  
  #define HEADER_COLOR	1
  #define GROUP_COLOR	2
- #define SUBJECT_COLOR	3
  #define AUTHOR_COLOR	4
  #define ERROR_COLOR	5
  #define CURSOR_COLOR	6
--- 89,103 ----
  
  extern int slrn_sys_system (char *);
  
+ #ifdef HAVE_SETLOCALE
+ # ifdef LC_TIME
+ extern char *Slrn_Date_Locale;
+ # endif
+ #endif
+ extern int Slrn_Use_Localtime;
+ 
  #define HEADER_COLOR	1
  #define GROUP_COLOR	2
  #define AUTHOR_COLOR	4
  #define ERROR_COLOR	5
  #define CURSOR_COLOR	6
***************
*** 96,102 ****
  #define PGP_SIGNATURE_COLOR 9
  #define SIGNATURE_COLOR 10
  #define THREAD_NUM_COLOR 11
- #define HIGH_SCORE_COLOR 12
  #define MENU_PRESS_COLOR 13
  #define HEADER_NUMBER_COLOR 14
  #define GROUP_DESCR_COLOR 15
--- 106,111 ----
***************
*** 111,120 ****
  #define SELECT_COLOR		24
  #define VERBATIM_COLOR		25
  #define DATE_COLOR		36
  
  #define BOLD_COLOR		30
  #define UNDERLINE_COLOR		31
  #define ITALICS_COLOR		32
! #define QUOTE_COLOR	40
  
  #endif				       /* _SLRN_SLRN_H_ */
--- 120,138 ----
  #define SELECT_COLOR		24
  #define VERBATIM_COLOR		25
  #define DATE_COLOR		36
+ /* SUBJECT_COLOR + 5 == UNREAD_SUBJECT_COLOR etc. */
+ #define SUBJECT_COLOR		40
+ #define NEG_SCORE_COLOR		41
+ #define POS_SCORE_COLOR		42
+ #define HIGH_SCORE_COLOR	43
+ #define UNREAD_SUBJECT_COLOR	45
+ #define UNREAD_NEG_SCORE_COLOR	46
+ #define UNREAD_POS_SCORE_COLOR	47
+ #define UNREAD_HIGH_SCORE_COLOR	48
  
  #define BOLD_COLOR		30
  #define UNDERLINE_COLOR		31
  #define ITALICS_COLOR		32
! #define QUOTE_COLOR	50
  
  #endif				       /* _SLRN_SLRN_H_ */
diff -cr slrn-0.9.6.3.orig/src/slrnpull.c slrn-0.9.6.3/src/slrnpull.c
*** slrn-0.9.6.3.orig/src/slrnpull.c	Mon Sep 18 00:35:31 2000
--- slrn-0.9.6.3/src/slrnpull.c	Tue Jan  2 21:09:19 2001
***************
*** 64,69 ****
--- 64,70 ----
  #include "slrndir.h"
  #include "version.h"
  
+ #include "sortdate.c"
  #include "score.c"
  #include "xover.c"
  
diff -cr slrn-0.9.6.3.orig/src/sltcp.h slrn-0.9.6.3/src/sltcp.h
*** slrn-0.9.6.3.orig/src/sltcp.h	Mon Sep 18 00:35:24 2000
--- slrn-0.9.6.3/src/sltcp.h	Tue Jan  2 21:08:11 2001
***************
*** 56,61 ****
--- 56,63 ----
  extern int sltcp_open_sltcp (void);
  extern int sltcp_close_sltcp (void);
  
+ extern int SLtcp_TimeOut_Secs;
+ 
  #endif
  
  #endif
diff -cr slrn-0.9.6.3.orig/src/sortdate.c slrn-0.9.6.3/src/sortdate.c
*** slrn-0.9.6.3.orig/src/sortdate.c	Mon Sep 18 00:35:32 2000
--- slrn-0.9.6.3/src/sortdate.c	Tue Jan  2 21:09:19 2001
***************
*** 18,30 ****
   Mass Ave, Cambridge, MA 02139, USA. 
  */
  #include "config.h"
! #include "slrnfeat.h"
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
  
! #include "slrn.h"
! #include "util.h"
  
  #ifndef isdigit
  # define isdigit(x) (((x)>='0')&&((x)<='9'))
--- 18,47 ----
   Mass Ave, Cambridge, MA 02139, USA. 
  */
  #include "config.h"
! #ifndef SLRNPULL_CODE
! # include "slrnfeat.h"
! #endif
  #include <stdio.h>
  #include <string.h>
  #include <ctype.h>
+ #include <time.h>
+ 
+ #ifdef HAVE_LOCALE_H
+ # include <locale.h>
+ #endif
  
! #ifndef SLRNPULL_CODE
! # include "slrn.h"
! # include "util.h"
! #endif
! 
! /* extern Global variables */
! #ifdef HAVE_SETLOCALE
! # ifdef LC_TIME
! char *Slrn_Date_Locale;
! # endif
! #endif
! int Slrn_Use_Localtime = 0;
  
  #ifndef isdigit
  # define isdigit(x) (((x)>='0')&&((x)<='9'))
***************
*** 66,72 ****
   * Beware: the calculations involving leap years, etc... are naive.
   */
  
! #define THE_YEAR_0		1992L  /* leap year */
  #define IS_LEAP_YEAR(y)		(((y) % 4) == 0)
  
  typedef struct 
--- 83,89 ----
   * Beware: the calculations involving leap years, etc... are naive.
   */
  
! #define THE_YEAR_0		1970L  /* no leap year */
  #define IS_LEAP_YEAR(y)		(((y) % 4) == 0)
  
  typedef struct 
***************
*** 298,304 ****
     /* add that to number of days since beginning of time */
     year -= THE_YEAR_0;
     day += year * 365 + year / 4;
!    if ((year % 4) == 1) day++;
     
     /* Adjust hours for timezone */
     hours -= tz / 100;
--- 315,321 ----
     /* add that to number of days since beginning of time */
     year -= THE_YEAR_0;
     day += year * 365 + year / 4;
!    if ((year % 4) == 3) day++;
     
     /* Adjust hours for timezone */
     hours -= tz / 100;
***************
*** 309,312 ****
--- 326,359 ----
     seconds += 60L * (minutes + 60L * (hours +  24L * day));
     
     return seconds;
+ }
+ 
+ /* Formats a given "date" (as understood by slrn_date_to_order_parm) according
+  * to the format specification "format" (see strftime(3)) */
+ void slrn_strftime (char *s, size_t max, const char *format, char *date)
+ {
+    time_t date_t;
+    struct tm *date_tm;
+ 
+ #ifdef HAVE_SETLOCALE
+ # ifdef LC_TIME
+    if (Slrn_Date_Locale != NULL)
+      (void) setlocale (LC_TIME, Slrn_Date_Locale);
+ # endif
+ #endif
+    
+    date_t = (time_t) slrn_date_to_order_parm (date);
+    
+    if (Slrn_Use_Localtime)
+      date_tm = localtime (&date_t);
+    else
+      date_tm = gmtime (&date_t);
+    
+    (void) strftime (s, max, format, date_tm);
+ 
+ #ifdef HAVE_SETLOCALE
+ # ifdef LC_TIME
+    (void) setlocale (LC_TIME, "C");
+ # endif
+ #endif
  }
diff -cr slrn-0.9.6.3.orig/src/spool.c slrn-0.9.6.3/src/spool.c
*** slrn-0.9.6.3.orig/src/spool.c	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/spool.c	Tue Jan  2 20:59:49 2001
***************
*** 61,66 ****
--- 61,67 ----
  static int spool_read_xover (char *, unsigned int);
  static int spool_read_xpat (char *, unsigned int);
  static int spool_article_num_exists (int);
+ static int spool_get_bytes (int clear);
  
  static Slrn_Server_Obj_Type Spool_Server_Obj;
  
***************
*** 85,90 ****
--- 86,93 ----
  static int spool_fakeactive_read_line(char *, int);
  static int Spool_fakeactive_newsgroups=0;
  
+ static int bytes_read=0;
+ 
  #if DEBUG_SPOOL
  # include <stdarg.h>
  static void spool_debug (char *fmt, ...)
***************
*** 1005,1010 ****
--- 1008,1016 ----
       }
  
     len = strlen(line);
+ 
+    bytes_read += len;
+    
     if (len && (line [len - 1] == '\n'))
       line [len-1] = '\0';
  
***************
*** 1390,1395 ****
--- 1396,1412 ----
     spool_fclose_local ();
  }
  
+ static int spool_get_bytes (int clear)
+ {
+    int temp;
+    
+    temp = bytes_read;
+    if (clear)
+      bytes_read = 0;
+    
+    return temp;
+ }
+ 
  char *Slrn_Inn_Root;
  char *Slrn_Spool_Root;
  char *Slrn_Nov_Root;
***************
*** 1419,1424 ****
--- 1436,1442 ----
     Spool_Server_Obj.sv_nntp_xover = spool_nntp_xover;
     Spool_Server_Obj.sv_nntp_head = spool_nntp_head;
     Spool_Server_Obj.sv_nntp_next = spool_nntp_next;
+    Spool_Server_Obj.sv_nntp_bytes = spool_get_bytes;
  
     Slrn_Inn_Root = slrn_safe_strmalloc (SLRN_SPOOL_INNROOT);
     Slrn_Spool_Root = slrn_safe_strmalloc (SLRN_SPOOL_ROOT);
diff -cr slrn-0.9.6.3.orig/src/startup.c slrn-0.9.6.3/src/startup.c
*** slrn-0.9.6.3.orig/src/startup.c	Mon Sep 18 00:35:29 2000
--- slrn-0.9.6.3/src/startup.c	Tue Jan  2 21:10:58 2001
***************
*** 30,35 ****
--- 30,39 ----
  # include <stdlib.h>
  #endif
  
+ #ifdef HAVE_LOCALE_H
+ # include <locale.h>
+ #endif
+ 
  #include <string.h>
  #include <slang.h>
  
***************
*** 56,61 ****
--- 60,68 ----
  #include "server.h"
  #include "chmap.h"
  #include "print.h"
+ #if SLRN_USE_SLTCP
+ # include "sltcp.h"
+ #endif
  
  #ifdef VMS
  # include "vms.h"
***************
*** 360,383 ****
--- 367,402 ----
  #endif
  #if SLRN_HAS_SORT_BY_SCORE
       {"display_score", &Slrn_Display_Score},
+      {"display_zero_score", &Slrn_Display_Zero_Score},
+      {"color_score_by_score", &Slrn_Color_Score},
+      {"color_subject_by_score", &Slrn_Color_Subject},
  #else
       {"display_score", NULL},
  #endif
+      {"highlight_unread_subjects", &Slrn_Highlight_Unread},
       {"use_xgtitle", &Slrn_Use_Xgtitle},
       {"show_article", &Slrn_Startup_With_Article},
       {"author_display", NULL},
       {"display_author_realname", NULL},
       {"show_descriptions", &Slrn_Group_Display_Descriptions},
+      {"smart_quote", &Slrn_Smart_Quote},
       {"no_backups", &Slrn_No_Backups},
       {"beep", &SLtt_Ignore_Beep},
+      {"clock_in_top_status_line", &Slrn_Clock_In_Top_Status_Line},
       {"unsubscribe_new_groups", &Slrn_Unsubscribe_New_Groups},
       {"check_new_groups", &Slrn_Check_New_Groups},
       {"show_thread_subject", &Slrn_Show_Thread_Subject},
       {"mouse", &Slrn_Use_Mouse},
       {"query_next_group", &Slrn_Query_Next_Group},
       {"query_next_article", &Slrn_Query_Next_Article},
+ #if SLRN_USE_SLTCP
+      {"tcp_timeout", &SLtcp_TimeOut_Secs},
+ #else
+      {"tcp_timeout", NULL},
+ #endif
       {"confirm_actions", &Slrn_User_Wants_Confirmation},
       {"cc_followup", &Slrn_Auto_CC_To_Poster},
+      {"use_to_on_reply", &Slrn_Send_To_To},
       {"use_tmpdir", &Slrn_Use_Tmpdir},
       {"sorting_method", &Slrn_Sorting_Mode},
       {"uncollapse_threads", &Slrn_Threads_Visible},
***************
*** 392,402 ****
--- 411,424 ----
  #if !defined(IBMPC_SYSTEM)
       {"use_blink", &SLtt_Blink_Mode},
  #endif
+      {"warn_followup_to", &Slrn_Warn_Followup_To},
       {"wrap_flags", &Slrn_Wrap_Mode},
+      {"wrap_method", &Slrn_Wrap_Method},
       {"write_newsrc_flags", &Slrn_Write_Newsrc_Flags},
       {"query_read_group_cutoff", &Slrn_Query_Group_Cutoff},
       {"prompt_next_group", &Slrn_Prompt_Next_Group},
       {"use_header_numbers", &Slrn_Use_Header_Numbers},
+      {"use_localtime", &Slrn_Use_Localtime},
  #if SLRN_HAS_SPOILERS
       {"spoiler_char", &Slrn_Spoiler_Char},
       {"spoiler_display_mode", &Slrn_Spoiler_Display_Mode},
***************
*** 481,486 ****
--- 503,509 ----
       {"custom_headers", &Slrn_Post_Custom_Headers},
       {"followup_custom_headers", &Slrn_Followup_Custom_Headers},
       {"reply_custom_headers", &Slrn_Reply_Custom_Headers},
+      {"supersedes_custom_headers", &Slrn_Supersedes_Custom_Headers},
  #if SLRN_HAS_GROUPLENS
       {"grouplens_pseudoname", &Slrn_GroupLens_Pseudoname},
       {"grouplens_host", &Slrn_GroupLens_Host},
***************
*** 578,583 ****
--- 601,619 ----
       {"server_object", &Server_Object},
       {"post_object", &Post_Object},
       {"printer_name", &Slrn_Printer_Name},
+      {"strip_was_regexp", &Slrn_Strip_Was_Regexp},
+      {"signoff_string", &Slrn_Signoff_String},
+      {"overview_date_format", &Slrn_Overview_Date_Format},
+      {"followup_date_format", &Slrn_Followup_Date_Format},
+      {"date_locale",
+ #ifdef HAVE_SETLOCALE
+ # ifdef LC_TIME
+      &Slrn_Date_Locale
+ #else
+      NULL
+ # endif
+ #endif
+      },
       {NULL, NULL}
  };
  
***************
*** 727,733 ****
--- 763,771 ----
       {"italicstext", 	ITALICS_COLOR,		"magenta", 	DEF_BG, 0},
       {"menu",		MENU_COLOR,		"yellow",	"blue", SLTT_REV_MASK},
       {"menu_press",	MENU_PRESS_COLOR,	DEF_FG,		"yellow", 0},
+      {"neg_score",	NEG_SCORE_COLOR,	"green",	DEF_BG,	0},
       {"normal",		0,			DEF_FG,		DEF_BG, 0},
+      {"pos_score",	POS_SCORE_COLOR,	"blue",		DEF_BG,	SLTT_REV_MASK},
       {"pgpsignature",	PGP_SIGNATURE_COLOR,	"red",		DEF_BG, 0},
       {"quotes",		QUOTE_COLOR,		"red",		DEF_BG, 0},
       {"response_char",	RESPONSE_CHAR_COLOR,	"green", 	DEF_BG, SLTT_BOLD_MASK},
***************
*** 747,752 ****
--- 785,815 ----
  
  /*}}}*/
  
+ /* These are for internal use and automatically set by slrn */
+ static Color_Handle_Type Auto_Color_Handles[] = /*{{{*/
+ {
+      {"high_score",	UNREAD_HIGH_SCORE_COLOR,	"brightred",	DEF_BG,	SLTT_BOLD_MASK},
+      {"neg_score",	UNREAD_NEG_SCORE_COLOR,	"brightgreen",	DEF_BG,	SLTT_BOLD_MASK},
+      {"pos_score",	UNREAD_POS_SCORE_COLOR,	"brightblue",	DEF_BG, SLTT_REV_MASK | SLTT_BOLD_MASK},
+      {"subject",	UNREAD_SUBJECT_COLOR,	"white",	DEF_BG,	SLTT_BOLD_MASK},
+      {NULL, -1, NULL, NULL, 0}
+ };
+ 
+ static char* Bright_Color_Map[] =
+ {
+    "black", "gray",
+    "red", "brightred",
+    "green", "brightgreen",
+    "brown", "yellow",
+    "blue", "brightblue",
+    "magenta", "brightmagenta",
+    "cyan", "brightcyan",
+    "lightgray", "white",
+    NULL
+ };
+ 
+ /*}}}*/
+ 
  int slrn_set_object_color (char *name, char *fg, char *bg)
  {
     Color_Handle_Type *ct = Color_Handles;
***************
*** 755,761 ****
--- 818,851 ----
       {
  	if (!strcmp (ct->name, name))
  	  {
+ 	     Color_Handle_Type *ac = Auto_Color_Handles;
+ 	     
  	     SLtt_set_color (ct->value, name, fg, bg);
+ 	     
+ 	     while (ac->name != NULL)
+ 	       {
+ 		  if (!strcmp (ac->name, name))
+ 		    {
+ 		       int i = 0;
+ 		       char* bc;
+ 		       
+ 		       SLtt_set_color(ac->value, NULL, fg, bg);
+ 		       
+ 		       while ((bc = Bright_Color_Map[i]) != NULL)
+ 			 {
+ 			    if (!strcmp (bc, fg))
+ 			      {
+ 				 SLtt_set_color(ac->value, NULL,
+ 						Bright_Color_Map[i+1], bg);
+ 				 break;
+ 			      }
+ 			    i += 2;
+ 			 }
+ 		       break;
+ 		    }
+ 		  ac++;
+ 	       }
+ 	     
  	     return 0;
  	  }
  	ct++;
***************
*** 808,814 ****
--- 898,917 ----
       {
  	if (!strcmp (ct->name, what))
  	  {
+ 	     Color_Handle_Type *ac = Auto_Color_Handles;
+ 	     
  	     SLtt_set_mono (ct->value, NULL, mono_attr);
+ 	     
+ 	     while (ac->name != NULL)
+ 	       {
+ 		  if (!strcmp (ac->name, what))
+ 		    {
+ 		       SLtt_set_mono (ac->value, NULL, mono_attr | SLTT_BOLD_MASK);
+ 		       break;
+ 		    }
+ 		  ac++;
+ 	       }
+ 	     
  	     return 0;
  	  }
  	ct++;
***************
*** 1154,1159 ****
--- 1257,1269 ----
     Slrn_Ignore_Quote_Regexp[0] = compile_quote_regexp ("^ ?[:>]");
     
     h = Color_Handles;
+    while (h->name != NULL)
+      {
+ 	SLtt_set_color (h->value, NULL, h->fg, h->bg);
+ 	SLtt_set_mono (h->value, NULL, h->mono);
+ 	h++;
+      }
+    h = Auto_Color_Handles;
     while (h->name != NULL)
       {
  	SLtt_set_color (h->value, NULL, h->fg, h->bg);
diff -cr slrn-0.9.6.3.orig/src/version.h slrn-0.9.6.3/src/version.h
*** slrn-0.9.6.3.orig/src/version.h	Mon Sep 18 00:35:24 2000
--- slrn-0.9.6.3/src/version.h	Tue Jan  2 21:15:22 2001
***************
*** 18,24 ****
   Mass Ave, Cambridge, MA 02139, USA. 
  */
  
! #define SLRN_VERSION "0.9.6.3" /* Make sure to update version info in VMSMAKE.COM!!! */
  
  #ifndef SLRNPULL_CODE
  extern char *Slrn_Version;
--- 18,24 ----
   Mass Ave, Cambridge, MA 02139, USA. 
  */
  
! #define SLRN_VERSION "0.9.6.3pl4" /* Make sure to update version info in VMSMAKE.COM!!! */
  
  #ifndef SLRNPULL_CODE
  extern char *Slrn_Version;
